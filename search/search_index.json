{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Aula complementar Azure \u00b6 Bem vindo ao curso de Conceitos b\u00e1sicos de Nuvem com Azure 2022. \u00b6 Professor : Tiago Demay Hor\u00e1rio das aulas : Segunda - 18h - 20h Terca - 18h - 20h Quarta - 18h - 20h Ao final da atividade o aluno ser\u00e1 capaz de: \u00b6 Dar os primeiros passos na Azure. Entender conceitos b\u00e1sicos de computa\u00e7\u00e3o em nuvem. Criar uma aplica\u00e7\u00e3o Web Python - FLASK Modificar aplica\u00e7\u00f5es j\u00e1 criadas. Objetivo: \u00b6 Apresentar os conceitos de computacao em nuvem utilizando a CSM (Azure) A Prova final \u00e9 individual \u00b6 Brincadeira....... aqui n\u00e3o tem Prova!!!!!!!!!!","title":"Home"},{"location":"#aula-complementar-azure","text":"","title":"Aula complementar Azure"},{"location":"#bem-vindo-ao-curso-de-conceitos-basicos-de-nuvem-com-azure-2022","text":"Professor : Tiago Demay Hor\u00e1rio das aulas : Segunda - 18h - 20h Terca - 18h - 20h Quarta - 18h - 20h","title":"Bem vindo ao curso de Conceitos b\u00e1sicos de Nuvem com Azure 2022."},{"location":"#ao-final-da-atividade-o-aluno-sera-capaz-de","text":"Dar os primeiros passos na Azure. Entender conceitos b\u00e1sicos de computa\u00e7\u00e3o em nuvem. Criar uma aplica\u00e7\u00e3o Web Python - FLASK Modificar aplica\u00e7\u00f5es j\u00e1 criadas.","title":"Ao final da atividade o aluno ser\u00e1 capaz de:"},{"location":"#objetivo","text":"Apresentar os conceitos de computacao em nuvem utilizando a CSM (Azure)","title":"Objetivo:"},{"location":"#a-prova-final-e-individual","text":"Brincadeira....... aqui n\u00e3o tem Prova!!!!!!!!!!","title":"A Prova final \u00e9 individual"},{"location":"sobre/","text":"Burocracias \u00b6 Hor\u00e1rios: As aulas s\u00e3o presenciais, inicio 18hrs at\u00e9 20hrs. Para que possamos seguir com a atividade, \u00e9 necess\u00e1rio a conta de e-mail de Alunos Insper Plano de aulas Data Tema Conte\u00fado/Atividade 18/04/22 Conceitos b\u00e1sicos de Nuvem, acessando o Portal da Azure Entendendo conceito de computacao em nuvem, criando uma conta e passeando pelo CMS 19/04/22 Configurando ambiente e subindo uma aplica\u00e7\u00e3o Web Python- FLASK Instalando Azure CLI, Implementa\u00e7\u00e3o de aplicacao utilizando uma ferramenta de linha de comando multiplataforma 20/04/22 Modificando a aplica\u00e7\u00e3o. aprender a modificar a aplicacao via Dashboard da Azure.","title":"Burocracias"},{"location":"sobre/#burocracias","text":"Hor\u00e1rios: As aulas s\u00e3o presenciais, inicio 18hrs at\u00e9 20hrs. Para que possamos seguir com a atividade, \u00e9 necess\u00e1rio a conta de e-mail de Alunos Insper Plano de aulas Data Tema Conte\u00fado/Atividade 18/04/22 Conceitos b\u00e1sicos de Nuvem, acessando o Portal da Azure Entendendo conceito de computacao em nuvem, criando uma conta e passeando pelo CMS 19/04/22 Configurando ambiente e subindo uma aplica\u00e7\u00e3o Web Python- FLASK Instalando Azure CLI, Implementa\u00e7\u00e3o de aplicacao utilizando uma ferramenta de linha de comando multiplataforma 20/04/22 Modificando a aplica\u00e7\u00e3o. aprender a modificar a aplicacao via Dashboard da Azure.","title":"Burocracias"},{"location":"aulas/01/","text":"Introducao \u00b6 Virtualizacao \u00b6 CSM \u00b6 Nuvem? \u00b6 O que \u00e9 o Microsoft Azure? \u00b6 O Azure \u00e9 uma plataforma de computa\u00e7\u00e3o em nuvem lan\u00e7ada pela Microsoft em fevereiro de 2010. \u00c9 uma plataforma de nuvem aberta e flex\u00edvel que auxilia no desenvolvimento, armazenamento de dados, hospedagem de servi\u00e7os e gerenciamento de servi\u00e7os. A ferramenta do Azure hospeda aplicativos Web pela Internet com a ajuda de data centers da Microsoft. Conceitos de chave do Azure \u00b6 Agora, neste tutorial de no\u00e7\u00f5es b\u00e1sicas do Azure, veremos os principais conceitos do Azure, conforme listado abaixo: Nome do conceito Descri\u00e7\u00e3o Regions O Azure \u00e9 uma plataforma de nuvem global que est\u00e1 dispon\u00edvel em v\u00e1rias regi\u00f5es do mundo. Quando voc\u00ea solicita um servi\u00e7o, aplicativo ou VM no Azure, primeiro \u00e9 solicitado que voc\u00ea especifique uma regi\u00e3o. A regi\u00e3o selecionada representa o datacenter onde seu aplicativo \u00e9 executado. Datacenter No Azure, voc\u00ea pode implantar seus aplicativos em v\u00e1rios data centers em todo o mundo. Portanto, \u00e9 aconselh\u00e1vel selecionar uma regi\u00e3o que esteja mais pr\u00f3xima da maioria dos seus clientes. Ele ajuda voc\u00ea a reduzir a lat\u00eancia nas solicita\u00e7\u00f5es de rede. Azure portal O portal do Azure \u00e9 um aplicativo baseado na Web que pode ser usado para criar, gerenciar e remover recursos e servi\u00e7os do Azure. Ele est\u00e1 localizado em https://portal.azure.com . Resources O recurso do Azure \u00e9 um computador individual, dados de rede ou servi\u00e7os de hospedagem de aplicativos cobrados individualmente. Alguns recursos comuns s\u00e3o m\u00e1quinas virtuais (VM), conta de armazenamento ou bancos de dados SQL. Resource groups Um grupo de recursos do Azure \u00e9 um cont\u00eainer que cont\u00e9m recursos relacionados para uma solu\u00e7\u00e3o do Azure. Pode incluir todos os recursos ou apenas recursos que voc\u00ea deseja gerenciar. Azure PowerShell O PowerShell \u00e9 um conjunto de m\u00f3dulos que oferece cmdlets para gerenciar o Azure. Na maioria dos casos, voc\u00ea tem permiss\u00e3o para usar o comando cmdlets para as mesmas tarefas que est\u00e1 executando no portal do Azure. Azure command-line interface(CLI) A CLI do Azure \u00e9 uma ferramenta que voc\u00ea pode usar para criar, gerenciar e remover recursos do Azure da linha de comando. REST APIs O Azure \u00e9 constru\u00eddo em um conjunto de APIs REST que ajudam voc\u00ea a executar a mesma opera\u00e7\u00e3o que voc\u00ea faz no portal do Azure Ul. Ele permite que seus recursos e aplicativos do Azure sejam manipulados por meio de qualquer aplicativo de software de terceiros. Links para criar a Conta \u00b6 link1 link2 link3 link4 Azure para estudantes \u00b6 O Azure for Students permite que voc\u00ea comece com USD 100 em cr\u00e9ditos do Azure para serem usados \u200b\u200bnos primeiros 12 meses, al\u00e9m de alguns servi\u00e7os gratuitos conforme descrito abaixo (servi\u00e7os sujeitos a altera\u00e7\u00f5es) sem a necessidade de um cart\u00e3o de cr\u00e9dito na inscri\u00e7\u00e3o. Aplique aqui -> link Quickstart: Create a Linux virtual machine in the Azure portal \u00b6 Sign in to Azure \u00b6 Sign in to the Azure portal . Create virtual machine \u00b6 Type virtual machines in the search. Under Services , select Virtual machines . In the Virtual machines page, select Create and then Virtual machine . The Create a virtual machine page opens. In the Basics tab, under Project details , make sure the correct subscription is selected and then choose to Create new resource group. Type myResourceGroup for the name.*. Under Instance details , type myVM for the Virtual machine name , and choose Ubuntu 18.04 LTS - Gen2 for your Image . Leave the other defaults. The default size and pricing is only shown as an example. Size availability and pricing are dependent on your region and subscription. :::image type=\"content\" source=\"media/quick-create-portal/instance-details.png\" alt-text=\"Screenshot of the Instance details section where you provide a name for the virtual machine and select its region, image, and size.\"::: [!NOTE] Some users will now see the option to create VMs in multiple zones. To learn more about this new capability, see Create virtual machines in an availability zone . :::image type=\"content\" source=\"../media/create-portal-availability-zone/preview.png\" alt-text=\"Screenshot showing that you have the option to create virtual machines in multiple availability zones.\"::: Under Administrator account , select SSH public key . In Username type azureuser . For SSH public key source , leave the default of Generate new key pair , and then type myKey for the Key pair name . Under Inbound port rules > Public inbound ports , choose Allow selected ports and then select SSH (22) and HTTP (80) from the drop-down. Leave the remaining defaults and then select the Review + create button at the bottom of the page. On the Create a virtual machine page, you can see the details about the VM you are about to create. When you are ready, select Create . When the Generate new key pair window opens, select Download private key and create resource . Your key file will be download as myKey.pem . Make sure you know where the .pem file was downloaded, you will need the path to it in the next step. When the deployment is finished, select Go to resource . On the page for your new VM, select the public IP address and copy it to your clipboard. [!INCLUDE ephemeral-ip-note.md ] Connect to virtual machine \u00b6 Create an SSH connection with the VM. If you are on a Mac or Linux machine, open a Bash prompt. If you are on a Windows machine, open a PowerShell prompt. At your prompt, open an SSH connection to your virtual machine. Replace the IP address with the one from your VM, and replace the path to the .pem with the path to where the key file was downloaded. ssh -i .\\Downloads\\myKey1.pem azureuser@10.111.12.123 [!TIP] The SSH key you created can be used the next time your create a VM in Azure. Just select the Use a key stored in Azure for SSH public key source the next time you create a VM. You already have the private key on your computer, so you won't need to download anything. Install web server \u00b6 To see your VM in action, install the NGINX web server. From your SSH session, update your package sources and then install the latest NGINX package. sudo apt-get -y update sudo apt-get -y install nginx When done, type exit to leave the SSH session. View the web server in action \u00b6 Use a web browser of your choice to view the default NGINX welcome page. Type the public IP address of the VM as the web address. The public IP address can be found on the VM overview page or as part of the SSH connection string you used earlier. Clean up resources \u00b6 When no longer needed, you can delete the resource group, virtual machine, and all related resources. To do so, select the resource group for the virtual machine, select Delete , then confirm the name of the resource group to delete.","title":"01 - Introdu\u00e7\u00e3o"},{"location":"aulas/01/#introducao","text":"","title":"Introducao"},{"location":"aulas/01/#virtualizacao","text":"","title":"Virtualizacao"},{"location":"aulas/01/#csm","text":"","title":"CSM"},{"location":"aulas/01/#nuvem","text":"","title":"Nuvem?"},{"location":"aulas/01/#o-que-e-o-microsoft-azure","text":"O Azure \u00e9 uma plataforma de computa\u00e7\u00e3o em nuvem lan\u00e7ada pela Microsoft em fevereiro de 2010. \u00c9 uma plataforma de nuvem aberta e flex\u00edvel que auxilia no desenvolvimento, armazenamento de dados, hospedagem de servi\u00e7os e gerenciamento de servi\u00e7os. A ferramenta do Azure hospeda aplicativos Web pela Internet com a ajuda de data centers da Microsoft.","title":"O que \u00e9 o Microsoft Azure?"},{"location":"aulas/01/#conceitos-de-chave-do-azure","text":"Agora, neste tutorial de no\u00e7\u00f5es b\u00e1sicas do Azure, veremos os principais conceitos do Azure, conforme listado abaixo: Nome do conceito Descri\u00e7\u00e3o Regions O Azure \u00e9 uma plataforma de nuvem global que est\u00e1 dispon\u00edvel em v\u00e1rias regi\u00f5es do mundo. Quando voc\u00ea solicita um servi\u00e7o, aplicativo ou VM no Azure, primeiro \u00e9 solicitado que voc\u00ea especifique uma regi\u00e3o. A regi\u00e3o selecionada representa o datacenter onde seu aplicativo \u00e9 executado. Datacenter No Azure, voc\u00ea pode implantar seus aplicativos em v\u00e1rios data centers em todo o mundo. Portanto, \u00e9 aconselh\u00e1vel selecionar uma regi\u00e3o que esteja mais pr\u00f3xima da maioria dos seus clientes. Ele ajuda voc\u00ea a reduzir a lat\u00eancia nas solicita\u00e7\u00f5es de rede. Azure portal O portal do Azure \u00e9 um aplicativo baseado na Web que pode ser usado para criar, gerenciar e remover recursos e servi\u00e7os do Azure. Ele est\u00e1 localizado em https://portal.azure.com . Resources O recurso do Azure \u00e9 um computador individual, dados de rede ou servi\u00e7os de hospedagem de aplicativos cobrados individualmente. Alguns recursos comuns s\u00e3o m\u00e1quinas virtuais (VM), conta de armazenamento ou bancos de dados SQL. Resource groups Um grupo de recursos do Azure \u00e9 um cont\u00eainer que cont\u00e9m recursos relacionados para uma solu\u00e7\u00e3o do Azure. Pode incluir todos os recursos ou apenas recursos que voc\u00ea deseja gerenciar. Azure PowerShell O PowerShell \u00e9 um conjunto de m\u00f3dulos que oferece cmdlets para gerenciar o Azure. Na maioria dos casos, voc\u00ea tem permiss\u00e3o para usar o comando cmdlets para as mesmas tarefas que est\u00e1 executando no portal do Azure. Azure command-line interface(CLI) A CLI do Azure \u00e9 uma ferramenta que voc\u00ea pode usar para criar, gerenciar e remover recursos do Azure da linha de comando. REST APIs O Azure \u00e9 constru\u00eddo em um conjunto de APIs REST que ajudam voc\u00ea a executar a mesma opera\u00e7\u00e3o que voc\u00ea faz no portal do Azure Ul. Ele permite que seus recursos e aplicativos do Azure sejam manipulados por meio de qualquer aplicativo de software de terceiros.","title":"Conceitos de chave do Azure"},{"location":"aulas/01/#links-para-criar-a-conta","text":"link1 link2 link3 link4","title":"Links para criar a Conta"},{"location":"aulas/01/#azure-para-estudantes","text":"O Azure for Students permite que voc\u00ea comece com USD 100 em cr\u00e9ditos do Azure para serem usados \u200b\u200bnos primeiros 12 meses, al\u00e9m de alguns servi\u00e7os gratuitos conforme descrito abaixo (servi\u00e7os sujeitos a altera\u00e7\u00f5es) sem a necessidade de um cart\u00e3o de cr\u00e9dito na inscri\u00e7\u00e3o. Aplique aqui -> link","title":"Azure para estudantes"},{"location":"aulas/01/#quickstart-create-a-linux-virtual-machine-in-the-azure-portal","text":"","title":"Quickstart: Create a Linux virtual machine in the Azure portal"},{"location":"aulas/01/#sign-in-to-azure","text":"Sign in to the Azure portal .","title":"Sign in to Azure"},{"location":"aulas/01/#create-virtual-machine","text":"Type virtual machines in the search. Under Services , select Virtual machines . In the Virtual machines page, select Create and then Virtual machine . The Create a virtual machine page opens. In the Basics tab, under Project details , make sure the correct subscription is selected and then choose to Create new resource group. Type myResourceGroup for the name.*. Under Instance details , type myVM for the Virtual machine name , and choose Ubuntu 18.04 LTS - Gen2 for your Image . Leave the other defaults. The default size and pricing is only shown as an example. Size availability and pricing are dependent on your region and subscription. :::image type=\"content\" source=\"media/quick-create-portal/instance-details.png\" alt-text=\"Screenshot of the Instance details section where you provide a name for the virtual machine and select its region, image, and size.\"::: [!NOTE] Some users will now see the option to create VMs in multiple zones. To learn more about this new capability, see Create virtual machines in an availability zone . :::image type=\"content\" source=\"../media/create-portal-availability-zone/preview.png\" alt-text=\"Screenshot showing that you have the option to create virtual machines in multiple availability zones.\"::: Under Administrator account , select SSH public key . In Username type azureuser . For SSH public key source , leave the default of Generate new key pair , and then type myKey for the Key pair name . Under Inbound port rules > Public inbound ports , choose Allow selected ports and then select SSH (22) and HTTP (80) from the drop-down. Leave the remaining defaults and then select the Review + create button at the bottom of the page. On the Create a virtual machine page, you can see the details about the VM you are about to create. When you are ready, select Create . When the Generate new key pair window opens, select Download private key and create resource . Your key file will be download as myKey.pem . Make sure you know where the .pem file was downloaded, you will need the path to it in the next step. When the deployment is finished, select Go to resource . On the page for your new VM, select the public IP address and copy it to your clipboard. [!INCLUDE ephemeral-ip-note.md ]","title":"Create virtual machine"},{"location":"aulas/01/#connect-to-virtual-machine","text":"Create an SSH connection with the VM. If you are on a Mac or Linux machine, open a Bash prompt. If you are on a Windows machine, open a PowerShell prompt. At your prompt, open an SSH connection to your virtual machine. Replace the IP address with the one from your VM, and replace the path to the .pem with the path to where the key file was downloaded. ssh -i .\\Downloads\\myKey1.pem azureuser@10.111.12.123 [!TIP] The SSH key you created can be used the next time your create a VM in Azure. Just select the Use a key stored in Azure for SSH public key source the next time you create a VM. You already have the private key on your computer, so you won't need to download anything.","title":"Connect to virtual machine"},{"location":"aulas/01/#install-web-server","text":"To see your VM in action, install the NGINX web server. From your SSH session, update your package sources and then install the latest NGINX package. sudo apt-get -y update sudo apt-get -y install nginx When done, type exit to leave the SSH session.","title":"Install web server"},{"location":"aulas/01/#view-the-web-server-in-action","text":"Use a web browser of your choice to view the default NGINX welcome page. Type the public IP address of the VM as the web address. The public IP address can be found on the VM overview page or as part of the SSH connection string you used earlier.","title":"View the web server in action"},{"location":"aulas/01/#clean-up-resources","text":"When no longer needed, you can delete the resource group, virtual machine, and all related resources. To do so, select the resource group for the virtual machine, select Delete , then confirm the name of the resource group to delete.","title":"Clean up resources"},{"location":"aulas/03/","text":"04 - Medi\u00e7\u00e3o de desempenho \u00b6 Apesar de podermos medir o tempo que nosso programa demora usando o comando time , n\u00e3o conseguimos nenhuma informa\u00e7\u00e3o importante de qual parte do programa est\u00e1 consumindo mais tempo. Este processo de dissecar um programa e entender exatamente qual parte demora quanto \u00e9 chamada de Profiling . Software Para esta aula precisaremos dos seguintes pacotes instalados. valgrind - ferramenta de an\u00e1lise de c\u00f3digo execut\u00e1vel kcachegrind - visualizador de resultados do valgrind Warm-up: O problema da soma de uma matriz \u00b6 O c\u00f3digo abaixo apresenta duas formas de realizar a soma de todos os elementos de uma matriz. Compile o c\u00f3digo e execute. Voc\u00ea sabe dizer qual a diferen\u00e7a de naive_sum e improved_sum ? #include <iostream> #include <algorithm> using namespace std ; constexpr int M = 2048 ; constexpr int N = 2048 ; double naive_sum ( const double a [][ N ]){ double sum = 0.0 ; for ( int j = 0 ; j < N ; ++ j ) { for ( int i = 0 ; i < M ; ++ i ) sum += a [ i ][ j ]; } return sum ; } double improved_sum ( const double a [][ N ]) { double sum = 0.0 ; for ( int i = 0 ; i < M ; ++ i ) for ( int j = 0 ; j < N ; ++ j ) sum += a [ i ][ j ]; return sum ; } int main () { static double a [ M ][ N ]; fill_n ( & a [ 0 ][ 0 ], M * N , 1.0 / ( M * N )); cout << naive_sum ( a ) << endl ; static double b [ M ][ N ]; fill_n ( & b [ 0 ][ 0 ], M * N , 1.0 / ( M * N )); cout << improved_sum ( b ) << endl ; return 0 ; } Vamos usar o Valgrind para verificar se h\u00e1 diferen\u00e7as entre naive_sum e improved_sum . Supondo que o seu arquivo se chama sum.cpp execute: g++ -Wall -O3 -g sum.cpp -o sum E execute ent\u00e3o programa via valgrind : valgrind --tool=callgrind ./sum O valgrind ir\u00e1 retornar algo como: ==3079146== Callgrind, a call-graph generating cache profiler ==3079146== Copyright (C) 2002-2017, and GNU GPL'd, by Josef Weidendorfer et al. ==3079146== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info ==3079146== Command: ./sum ==3079146== ==3079146== For interactive control, run 'callgrind_control -h'. 1 1 ==3079146== ==3079146== Events : Ir ==3079146== Collected : 50553796 ==3079146== ==3079146== I refs: 50,553,796 Onde 3079146 \u00e9 o PID da execu\u00e7\u00e3o. Na sua m\u00e1quina ser\u00e1 um outro valor. Ele tamb\u00e9m gerou um arquivo callgrind.out.{PID} . Execute a ferramenta callgrind_annotate para verificar o resultado do profiling. callgrind_annotate callgrind.out.3079146 sum.cpp E seu output ser\u00e1 como segue: -------------------------------------------------------------------------------- Profile data file 'callgrind.out.3079146' (creator: callgrind-3.15.0) -------------------------------------------------------------------------------- I1 cache: D1 cache: LL cache: Timerange: Basic block 0 - 10863316 Trigger: Program termination Profiled target: ./sum (PID 3079146, part 1) Events recorded: Ir Events shown: Ir Event sort order: Ir Thresholds: 99 Include dirs: User annotated: sum.cpp Auto-annotation: off -------------------------------------------------------------------------------- Ir -------------------------------------------------------------------------------- 50,553,796 PROGRAM TOTALS -------------------------------------------------------------------------------- Ir file:function -------------------------------------------------------------------------------- 31,479,818 sum.cpp:main [/home/user/andre/profile/sum] 16,777,221 /usr/include/c++/9/bits/stl_algobase.h:main 948,840 /build/glibc-eX1tMB/glibc-2.31/elf/dl-lookup.c:_dl_lookup_symbol_x [/usr/lib/x86_64-linux-gnu/ld-2.31.so] 554,233 /build/glibc-eX1tMB/glibc-2.31/elf/dl-lookup.c:do_lookup_x [/usr/lib/x86_64-linux-gnu/ld-2.31.so] 273,488 /build/glibc-eX1tMB/glibc-2.31/elf/../sysdeps/x86_64/dl-machine.h:_dl_relocate_object 117,179 /build/glibc-eX1tMB/glibc-2.31/elf/dl-lookup.c:check_match [/usr/lib/x86_64-linux-gnu/ld-2.31.so] -------------------------------------------------------------------------------- -- User-annotated source: sum.cpp -------------------------------------------------------------------------------- Ir . #include<iostream> . #include<algorithm> . using namespace std; . . constexpr int M = 2048; . constexpr int N = 2048; . . double naive_sum(const double a[][N]){ 1 double sum = 0.0; 6,144 for(int j = 0; j < N; ++j) { 12,587,008 for(int i = 0; i < M; ++i) 4,194,304 sum += a[i][j]; . } . return sum; . } . . double improved_sum(const double a[][N]) { 4,097 double sum = 0.0; 8,192 for(int i = 0; i < M; ++i) 4,194,304 for(int j = 0; j < N; ++j) 10,485,760 sum +=a[i][j]; . return sum; . } . 5 int main() { . static double a[M][N]; . fill_n(&a[0][0], M*N, 1.0 / (M*N)); . cout << naive_sum(a) << endl; . static double b[M][N]; . fill_n(&b[0][0], M*N, 1.0 / (M*N)); . cout << improved_sum(b) << endl; . return 0; 6 } -------------------------------------------------------------------------------- Ir -------------------------------------------------------------------------------- 31,479,821 events annotated O que voc\u00ea pode dizer sobre o desempenho do programa? Por que h\u00e1 diferen\u00e7a de instruction fetch (IR) entre naive_sum e improved_sum ? Tip Dica: Verifique a discuss\u00e3o no StackOverflow sobre isso. Neste link https://stackoverflow.com/questions/9936132/why-does-the-order-of-the-loops-affect-performance-when-iterating-over-a-2d-arra Dist\u00e2ncia: Euclides ing\u00eanuo \u00b6 Compile o c\u00f3digo-fonte da implementa\u00e7\u00e3o ing\u00eanua que fizemos na aula passada, com profiling habilitado para medir os tempos de execu\u00e7\u00e3o. g++ -g euclides-ingenuo.cpp -o euclides-ingenuo Ap\u00f3s este passo, execute o programa usando o valgrind com as op\u00e7\u00f5es abaixo. valgrind --tool=callgrind ./seu_exec < entrada > saida Para mostrar os resultados usando o kcachegrind usamos o seguinte comando. kcachegrind callgrind.out.(pid aqui) O que tomou mais tempo de execu\u00e7\u00e3o da vers\u00e3o ing\u00eanua? Medindo os tempos no seu pr\u00f3prio programa \u00b6 Voc\u00ea vai perceber, ao executar a atividade anterior, que boa parte do tempo \u00e9 gasto mostrando a sa\u00edda no terminal. Isto nos leva \u00e0 primeira conclus\u00e3o da atividade de hoje: Entrada e sa\u00edda de dados s\u00e3o opera\u00e7\u00f5es muito lentas Example Fa\u00e7a o teste da demonstra\u00e7\u00e3o em seu pr\u00f3prio programa e anote abaixo, para as duas vers\u00f5es de calcula_distancias , o tempo relativo de execu\u00e7\u00e3o o n\u00famero absoluto de instru\u00e7\u00f5es executadas Question O n\u00famero absoluto de intru\u00e7\u00f5es executadas diminuiu significativamente depois de nossa otimiza\u00e7\u00e3o? Teoricamente s\u00f3 calculamos metade da matriz, esse n\u00famero \u00e9 quase metade da vers\u00e3o n\u00e3o otimizada? Voc\u00ea consegue dizer por que? Resposta Deve ter havido uma diminui\u00e7\u00e3o, mas n\u00e3o chega nem perto de metade. Isso ocorre por v\u00e1rias raz\u00f5es: nosso for duplo continua percorrendo a matriz inteira, apesar de s\u00f3 fazer o c\u00e1lculo em metade das posi\u00e7\u00f5es. alocamos a matriz elemento a elemento enquanto fazemos os c\u00e1lculos. Com isso em mente, vamos agora otimizar a fun\u00e7\u00e3o calcula_distancias . J\u00e1 sabemos que o efeito no tempo final n\u00e3o ser\u00e1 grande. Nosso objetivo ent\u00e3o ser\u00e1 verificar a seguinte afirma\u00e7\u00e3o. Dois algoritmos de mesma complexidade computacional podem ter tempos de execu\u00e7\u00e3o muito diferentes Question A resposta da quest\u00e3o anterior indica que s\u00f3 usar um if para evitar o c\u00e1lculo repetido n\u00e3o \u00e9 suficiente. Precisamos efetivamente fazer um for que percorre s\u00f3 metade da matriz. Supondo que a matriz j\u00e1 esteja inteira alocada, escreva em pseudo-c\u00f3digo como faz\u00ea-lo. Resposta para i=1..N: para j=i..N: DX = X[i] - X[j] DY = Y[i] - Y[j] DIST = sqrt(DX*DX + DY*DY) D[i,j] = DIST D[j,i] = DIST Matrizes (vers\u00e3o 2) \u00b6 Nossa implementa\u00e7\u00e3o usando vector<vector<double>> tem um problema s\u00e9rio: ela aloca elemento a elemento uma estrutura grande que j\u00e1 sabemos o tamanho de in\u00edcio. Seria muito melhor se pud\u00e9ssemos alocar todas as N^2 N^2 posi\u00e7\u00f5es da matriz de uma s\u00f3 vez! Fazemos isso trabalhando com um layout de mem\u00f3ria cont\u00ednuo. Ou seja, armazenaremos a matriz linha a linha como um \u00fanico vetor de tamanho n*n . Temos v\u00e1rias vantagens: tempo de aloca\u00e7\u00e3o de mem\u00f3ria \u00e9 reduzido, j\u00e1 que s\u00f3 fazemos uma chamada podemos acessar qualquer posi\u00e7\u00e3o a qualquer momento melhor desempenho de cache A figura abaixo exemplifica esse layout de mem\u00f3ria: Question Em uma matriz de tamanho 4x7 (4 linhas, 7 colunas), qual \u00e9 o elemento do vetor que representa a posi\u00e7\u00e3o 2x5 (linha 3, coluna 6)? Details Estamos considerando que come\u00e7amos a contar as linhas e colunas do zero. A posi\u00e7\u00e3o do vetor \u00e9 19 . Este n\u00famero \u00e9 obtido pela express\u00e3o i * c + j i \u00e9 a linha a ser acessada j \u00e9 a coluna c \u00e9 o n\u00famero de colunas da matriz 19 = 2 * 7 + 5 Tip Conseguimos redimensionar um vetor usando o m\u00e9todo resize , que recebe o novo n\u00famero de elementos do vetor. Example Fa\u00e7a uma terceira vers\u00e3o de calcula_distancias , desta vez usando o layout de mem\u00f3ria acima. Verifique que o programa continua retornando os mesmos resultados que as vers\u00f5es anteriores. Question Rode novamente os testes de profiling e verifique o n\u00famero de instru\u00e7\u00f5es para esta nova vers\u00e3o. Compare este valor com os anteriores e comente.","title":"03 - Modificando"},{"location":"aulas/03/#04-medicao-de-desempenho","text":"Apesar de podermos medir o tempo que nosso programa demora usando o comando time , n\u00e3o conseguimos nenhuma informa\u00e7\u00e3o importante de qual parte do programa est\u00e1 consumindo mais tempo. Este processo de dissecar um programa e entender exatamente qual parte demora quanto \u00e9 chamada de Profiling . Software Para esta aula precisaremos dos seguintes pacotes instalados. valgrind - ferramenta de an\u00e1lise de c\u00f3digo execut\u00e1vel kcachegrind - visualizador de resultados do valgrind","title":"04 - Medi\u00e7\u00e3o de desempenho"},{"location":"aulas/03/#warm-up-o-problema-da-soma-de-uma-matriz","text":"O c\u00f3digo abaixo apresenta duas formas de realizar a soma de todos os elementos de uma matriz. Compile o c\u00f3digo e execute. Voc\u00ea sabe dizer qual a diferen\u00e7a de naive_sum e improved_sum ? #include <iostream> #include <algorithm> using namespace std ; constexpr int M = 2048 ; constexpr int N = 2048 ; double naive_sum ( const double a [][ N ]){ double sum = 0.0 ; for ( int j = 0 ; j < N ; ++ j ) { for ( int i = 0 ; i < M ; ++ i ) sum += a [ i ][ j ]; } return sum ; } double improved_sum ( const double a [][ N ]) { double sum = 0.0 ; for ( int i = 0 ; i < M ; ++ i ) for ( int j = 0 ; j < N ; ++ j ) sum += a [ i ][ j ]; return sum ; } int main () { static double a [ M ][ N ]; fill_n ( & a [ 0 ][ 0 ], M * N , 1.0 / ( M * N )); cout << naive_sum ( a ) << endl ; static double b [ M ][ N ]; fill_n ( & b [ 0 ][ 0 ], M * N , 1.0 / ( M * N )); cout << improved_sum ( b ) << endl ; return 0 ; } Vamos usar o Valgrind para verificar se h\u00e1 diferen\u00e7as entre naive_sum e improved_sum . Supondo que o seu arquivo se chama sum.cpp execute: g++ -Wall -O3 -g sum.cpp -o sum E execute ent\u00e3o programa via valgrind : valgrind --tool=callgrind ./sum O valgrind ir\u00e1 retornar algo como: ==3079146== Callgrind, a call-graph generating cache profiler ==3079146== Copyright (C) 2002-2017, and GNU GPL'd, by Josef Weidendorfer et al. ==3079146== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info ==3079146== Command: ./sum ==3079146== ==3079146== For interactive control, run 'callgrind_control -h'. 1 1 ==3079146== ==3079146== Events : Ir ==3079146== Collected : 50553796 ==3079146== ==3079146== I refs: 50,553,796 Onde 3079146 \u00e9 o PID da execu\u00e7\u00e3o. Na sua m\u00e1quina ser\u00e1 um outro valor. Ele tamb\u00e9m gerou um arquivo callgrind.out.{PID} . Execute a ferramenta callgrind_annotate para verificar o resultado do profiling. callgrind_annotate callgrind.out.3079146 sum.cpp E seu output ser\u00e1 como segue: -------------------------------------------------------------------------------- Profile data file 'callgrind.out.3079146' (creator: callgrind-3.15.0) -------------------------------------------------------------------------------- I1 cache: D1 cache: LL cache: Timerange: Basic block 0 - 10863316 Trigger: Program termination Profiled target: ./sum (PID 3079146, part 1) Events recorded: Ir Events shown: Ir Event sort order: Ir Thresholds: 99 Include dirs: User annotated: sum.cpp Auto-annotation: off -------------------------------------------------------------------------------- Ir -------------------------------------------------------------------------------- 50,553,796 PROGRAM TOTALS -------------------------------------------------------------------------------- Ir file:function -------------------------------------------------------------------------------- 31,479,818 sum.cpp:main [/home/user/andre/profile/sum] 16,777,221 /usr/include/c++/9/bits/stl_algobase.h:main 948,840 /build/glibc-eX1tMB/glibc-2.31/elf/dl-lookup.c:_dl_lookup_symbol_x [/usr/lib/x86_64-linux-gnu/ld-2.31.so] 554,233 /build/glibc-eX1tMB/glibc-2.31/elf/dl-lookup.c:do_lookup_x [/usr/lib/x86_64-linux-gnu/ld-2.31.so] 273,488 /build/glibc-eX1tMB/glibc-2.31/elf/../sysdeps/x86_64/dl-machine.h:_dl_relocate_object 117,179 /build/glibc-eX1tMB/glibc-2.31/elf/dl-lookup.c:check_match [/usr/lib/x86_64-linux-gnu/ld-2.31.so] -------------------------------------------------------------------------------- -- User-annotated source: sum.cpp -------------------------------------------------------------------------------- Ir . #include<iostream> . #include<algorithm> . using namespace std; . . constexpr int M = 2048; . constexpr int N = 2048; . . double naive_sum(const double a[][N]){ 1 double sum = 0.0; 6,144 for(int j = 0; j < N; ++j) { 12,587,008 for(int i = 0; i < M; ++i) 4,194,304 sum += a[i][j]; . } . return sum; . } . . double improved_sum(const double a[][N]) { 4,097 double sum = 0.0; 8,192 for(int i = 0; i < M; ++i) 4,194,304 for(int j = 0; j < N; ++j) 10,485,760 sum +=a[i][j]; . return sum; . } . 5 int main() { . static double a[M][N]; . fill_n(&a[0][0], M*N, 1.0 / (M*N)); . cout << naive_sum(a) << endl; . static double b[M][N]; . fill_n(&b[0][0], M*N, 1.0 / (M*N)); . cout << improved_sum(b) << endl; . return 0; 6 } -------------------------------------------------------------------------------- Ir -------------------------------------------------------------------------------- 31,479,821 events annotated O que voc\u00ea pode dizer sobre o desempenho do programa? Por que h\u00e1 diferen\u00e7a de instruction fetch (IR) entre naive_sum e improved_sum ? Tip Dica: Verifique a discuss\u00e3o no StackOverflow sobre isso. Neste link https://stackoverflow.com/questions/9936132/why-does-the-order-of-the-loops-affect-performance-when-iterating-over-a-2d-arra","title":"Warm-up: O problema da soma de uma matriz"},{"location":"aulas/03/#distancia-euclides-ingenuo","text":"Compile o c\u00f3digo-fonte da implementa\u00e7\u00e3o ing\u00eanua que fizemos na aula passada, com profiling habilitado para medir os tempos de execu\u00e7\u00e3o. g++ -g euclides-ingenuo.cpp -o euclides-ingenuo Ap\u00f3s este passo, execute o programa usando o valgrind com as op\u00e7\u00f5es abaixo. valgrind --tool=callgrind ./seu_exec < entrada > saida Para mostrar os resultados usando o kcachegrind usamos o seguinte comando. kcachegrind callgrind.out.(pid aqui) O que tomou mais tempo de execu\u00e7\u00e3o da vers\u00e3o ing\u00eanua?","title":"Dist\u00e2ncia: Euclides ing\u00eanuo"},{"location":"aulas/03/#medindo-os-tempos-no-seu-proprio-programa","text":"Voc\u00ea vai perceber, ao executar a atividade anterior, que boa parte do tempo \u00e9 gasto mostrando a sa\u00edda no terminal. Isto nos leva \u00e0 primeira conclus\u00e3o da atividade de hoje: Entrada e sa\u00edda de dados s\u00e3o opera\u00e7\u00f5es muito lentas Example Fa\u00e7a o teste da demonstra\u00e7\u00e3o em seu pr\u00f3prio programa e anote abaixo, para as duas vers\u00f5es de calcula_distancias , o tempo relativo de execu\u00e7\u00e3o o n\u00famero absoluto de instru\u00e7\u00f5es executadas Question O n\u00famero absoluto de intru\u00e7\u00f5es executadas diminuiu significativamente depois de nossa otimiza\u00e7\u00e3o? Teoricamente s\u00f3 calculamos metade da matriz, esse n\u00famero \u00e9 quase metade da vers\u00e3o n\u00e3o otimizada? Voc\u00ea consegue dizer por que? Resposta Deve ter havido uma diminui\u00e7\u00e3o, mas n\u00e3o chega nem perto de metade. Isso ocorre por v\u00e1rias raz\u00f5es: nosso for duplo continua percorrendo a matriz inteira, apesar de s\u00f3 fazer o c\u00e1lculo em metade das posi\u00e7\u00f5es. alocamos a matriz elemento a elemento enquanto fazemos os c\u00e1lculos. Com isso em mente, vamos agora otimizar a fun\u00e7\u00e3o calcula_distancias . J\u00e1 sabemos que o efeito no tempo final n\u00e3o ser\u00e1 grande. Nosso objetivo ent\u00e3o ser\u00e1 verificar a seguinte afirma\u00e7\u00e3o. Dois algoritmos de mesma complexidade computacional podem ter tempos de execu\u00e7\u00e3o muito diferentes Question A resposta da quest\u00e3o anterior indica que s\u00f3 usar um if para evitar o c\u00e1lculo repetido n\u00e3o \u00e9 suficiente. Precisamos efetivamente fazer um for que percorre s\u00f3 metade da matriz. Supondo que a matriz j\u00e1 esteja inteira alocada, escreva em pseudo-c\u00f3digo como faz\u00ea-lo. Resposta para i=1..N: para j=i..N: DX = X[i] - X[j] DY = Y[i] - Y[j] DIST = sqrt(DX*DX + DY*DY) D[i,j] = DIST D[j,i] = DIST","title":"Medindo os tempos no seu pr\u00f3prio programa"},{"location":"aulas/03/#matrizes-versao-2","text":"Nossa implementa\u00e7\u00e3o usando vector<vector<double>> tem um problema s\u00e9rio: ela aloca elemento a elemento uma estrutura grande que j\u00e1 sabemos o tamanho de in\u00edcio. Seria muito melhor se pud\u00e9ssemos alocar todas as N^2 N^2 posi\u00e7\u00f5es da matriz de uma s\u00f3 vez! Fazemos isso trabalhando com um layout de mem\u00f3ria cont\u00ednuo. Ou seja, armazenaremos a matriz linha a linha como um \u00fanico vetor de tamanho n*n . Temos v\u00e1rias vantagens: tempo de aloca\u00e7\u00e3o de mem\u00f3ria \u00e9 reduzido, j\u00e1 que s\u00f3 fazemos uma chamada podemos acessar qualquer posi\u00e7\u00e3o a qualquer momento melhor desempenho de cache A figura abaixo exemplifica esse layout de mem\u00f3ria: Question Em uma matriz de tamanho 4x7 (4 linhas, 7 colunas), qual \u00e9 o elemento do vetor que representa a posi\u00e7\u00e3o 2x5 (linha 3, coluna 6)? Details Estamos considerando que come\u00e7amos a contar as linhas e colunas do zero. A posi\u00e7\u00e3o do vetor \u00e9 19 . Este n\u00famero \u00e9 obtido pela express\u00e3o i * c + j i \u00e9 a linha a ser acessada j \u00e9 a coluna c \u00e9 o n\u00famero de colunas da matriz 19 = 2 * 7 + 5 Tip Conseguimos redimensionar um vetor usando o m\u00e9todo resize , que recebe o novo n\u00famero de elementos do vetor. Example Fa\u00e7a uma terceira vers\u00e3o de calcula_distancias , desta vez usando o layout de mem\u00f3ria acima. Verifique que o programa continua retornando os mesmos resultados que as vers\u00f5es anteriores. Question Rode novamente os testes de profiling e verifique o n\u00famero de instru\u00e7\u00f5es para esta nova vers\u00e3o. Compare este valor com os anteriores e comente.","title":"Matrizes (vers\u00e3o 2)"},{"location":"projetos/","text":"Alinhamento de Sequencias de DNA \u00b6 Em Bioinform\u00e1tica, o problema de alinhamento de sequ\u00eancias de DNA consiste no processo de comparar duas ou mais sequ\u00eancias de bases de forma a se observar seu n\u00edvel de similaridade. Trata-se de um problema extremamente importante no contexto atual, pois permite comparar sequencias virais de SARS-COV2 em bancos de dados gen\u00f4micos para detec\u00e7\u00e3o de novas muta\u00e7\u00f5es. O n\u00edvel de similaridade pode ser calculado com base em acertos (match) e erros (gap e mismatch) . Os acertos contribuem com sinal positivo (+) para o n\u00edvel de similaridade e, os erros, com sinal negativo (-). Abaixo temos um exemplo de c\u00e1lculo do n\u00edvel similaridade: Vamos associar a pontua\u00e7\u00e3o +1 (match) e as penalidades -1 (gap) e -4 (mismatch) . Assim, teremos o seguinte n\u00edvel de similaridade: 23 matches x (+1) + 4 gaps x (-1) + 3 mismatches x (-4) = 23-4-12 = 7 Neste contexto, o problema de alinhamento de sequencias de DNA pode ser colocado da seguinte forma: Dadas duas sequencias de DNA, com as bases A,T,G,C e - para indicar gap, encontrar o alinhamento que maximize o n\u00edvel de similaridade. Neste projeto, seu objetivo ser\u00e1 construir programas para encontrar este alinhamento de n\u00edvel m\u00e1ximo de similaridade, utilizando v\u00e1rias estrat\u00e9gias. Cada um dos seus programas tomar\u00e1 como entrada a seguinte estrutura: a primeira linha cont\u00e9m dois n\u00fameros n e m , onde n \u00e9 o tamanho da primeira sequencia e, m , o tamanho da segunda. Assuma n \u2264 200 e m \u2264 200 . A segunda linha cont\u00e9m as bases da primeira sequencia e, a terceira linha, as bases da segunda. 5 7 AT-CC TTTCCAA A sa\u00edda deve ser uma linha com um n\u00famero inteiro indicando o n\u00edvel m\u00e1ximo de similaridade. 2 Neste caso, este n\u00edvel m\u00e1ximo de similaridade pode ser associado ao alinhamento T-CC/TTCC (1-1+1+1=2) ou a CC/CC(1+1=2). Voc\u00ea pode usar o c\u00f3digo python abaixo para gerar inst\u00e2ncias aleat\u00f3rias para seus testes. import random n = 10 # tamanho da primeira sequ\u00eancia m = 40 # tamanho da segunda sequ\u00eancia file = 'dna.seq' # nome do arquivo a ser gerado f = open ( file , 'w' ) seq = [ str ( n ) + ' \\n ' , str ( m ) + ' \\n ' , '' . join ( random . choices ([ 'A' , 'T' , 'C' , 'G' , '-' ], k = n )) + ' \\n ' , '' . join ( random . choices ([ 'A' , 'T' , 'C' , 'G' , '-' ], k = m ))] f . writelines ( seq ) f . close () print ( '' . join ( seq )) Um poss\u00edvel output para este c\u00f3digo acima \u00e9: 10 40 TGGCGAT--C AGC-TCTCTTC--ATT--CAC-TACACCGACA-CGC-G-A Estrat\u00e9gias a serem estudadas \u00b6 Para cada estrat\u00e9gia que vamos estudar, implementaremos um programa correspondente no projeto. Veja abaixo as datas de entrega e descri\u00e7\u00f5es de cada estrat\u00e9gia a ser implementada. Em geral, o enunciado de uma parte \u00e9 liberado ap\u00f3s a data de entrega da parte anterior. Solu\u00e7\u00e3o Heur\u00edstica (18/03) Busca Local (01/04) Busca Exaustiva (15/04) Relat\u00f3rio Preliminar (29/04) Paralelismo Multicore (13/05) Paralelismo GPU (27/05) Relat\u00f3rio Final (03/06) Avalia\u00e7\u00e3o \u00b6 O projeto ser\u00e1 avaliado usando rubricas para as entregas b\u00e1sicas. As rubricas de avalia\u00e7\u00e3o dos relat\u00f3rios estar\u00e3o descritas em suas p\u00e1ginas de entrega. Conceito D \u00b6 Algum dos seguintes itens n\u00e3o foi entregue corretamente ou possui problemas s\u00e9rios (no caso do relat\u00f3rio final). Solu\u00e7\u00e3o heur\u00edstica Busca local Busca exaustiva Busca local paralela (CPU) Busca local paralela (GPU) Relat\u00f3rio preliminar Relat\u00f3rio final Conceito C \u00b6 Todas as atividades abaixo foram validadas pelo corretor e (no caso do relat\u00f3rio final) alcan\u00e7aram qualidade m\u00ednima exigida. Solu\u00e7\u00e3o heur\u00edstica Busca local Busca exaustiva Busca local paralela (CPU) Busca local paralela (GPU) Relat\u00f3rio preliminar Relat\u00f3rio final Conceito C+ \u00b6 Al\u00e9m do j\u00e1 validado no conceito C , os relat\u00f3rios entregues n\u00e3o tinham nenhum ponto em desenvolvimento ou insatisfat\u00f3rio na rubrica do relat\u00f3rio. Conceitos avan\u00e7ados \u00b6 A partir do conceito C+ cada atividade avan\u00e7ada vale meio conceito. Elas ser\u00e3o listadas aqui conforme o semestre avan\u00e7a e ser\u00e3o testadas pela checagem de resultados dispon\u00edvel no reposit\u00f3rio de entregas.","title":"Alinhamento de Sequencias de DNA"},{"location":"projetos/#alinhamento-de-sequencias-de-dna","text":"Em Bioinform\u00e1tica, o problema de alinhamento de sequ\u00eancias de DNA consiste no processo de comparar duas ou mais sequ\u00eancias de bases de forma a se observar seu n\u00edvel de similaridade. Trata-se de um problema extremamente importante no contexto atual, pois permite comparar sequencias virais de SARS-COV2 em bancos de dados gen\u00f4micos para detec\u00e7\u00e3o de novas muta\u00e7\u00f5es. O n\u00edvel de similaridade pode ser calculado com base em acertos (match) e erros (gap e mismatch) . Os acertos contribuem com sinal positivo (+) para o n\u00edvel de similaridade e, os erros, com sinal negativo (-). Abaixo temos um exemplo de c\u00e1lculo do n\u00edvel similaridade: Vamos associar a pontua\u00e7\u00e3o +1 (match) e as penalidades -1 (gap) e -4 (mismatch) . Assim, teremos o seguinte n\u00edvel de similaridade: 23 matches x (+1) + 4 gaps x (-1) + 3 mismatches x (-4) = 23-4-12 = 7 Neste contexto, o problema de alinhamento de sequencias de DNA pode ser colocado da seguinte forma: Dadas duas sequencias de DNA, com as bases A,T,G,C e - para indicar gap, encontrar o alinhamento que maximize o n\u00edvel de similaridade. Neste projeto, seu objetivo ser\u00e1 construir programas para encontrar este alinhamento de n\u00edvel m\u00e1ximo de similaridade, utilizando v\u00e1rias estrat\u00e9gias. Cada um dos seus programas tomar\u00e1 como entrada a seguinte estrutura: a primeira linha cont\u00e9m dois n\u00fameros n e m , onde n \u00e9 o tamanho da primeira sequencia e, m , o tamanho da segunda. Assuma n \u2264 200 e m \u2264 200 . A segunda linha cont\u00e9m as bases da primeira sequencia e, a terceira linha, as bases da segunda. 5 7 AT-CC TTTCCAA A sa\u00edda deve ser uma linha com um n\u00famero inteiro indicando o n\u00edvel m\u00e1ximo de similaridade. 2 Neste caso, este n\u00edvel m\u00e1ximo de similaridade pode ser associado ao alinhamento T-CC/TTCC (1-1+1+1=2) ou a CC/CC(1+1=2). Voc\u00ea pode usar o c\u00f3digo python abaixo para gerar inst\u00e2ncias aleat\u00f3rias para seus testes. import random n = 10 # tamanho da primeira sequ\u00eancia m = 40 # tamanho da segunda sequ\u00eancia file = 'dna.seq' # nome do arquivo a ser gerado f = open ( file , 'w' ) seq = [ str ( n ) + ' \\n ' , str ( m ) + ' \\n ' , '' . join ( random . choices ([ 'A' , 'T' , 'C' , 'G' , '-' ], k = n )) + ' \\n ' , '' . join ( random . choices ([ 'A' , 'T' , 'C' , 'G' , '-' ], k = m ))] f . writelines ( seq ) f . close () print ( '' . join ( seq )) Um poss\u00edvel output para este c\u00f3digo acima \u00e9: 10 40 TGGCGAT--C AGC-TCTCTTC--ATT--CAC-TACACCGACA-CGC-G-A","title":"Alinhamento de Sequencias de DNA"},{"location":"projetos/#estrategias-a-serem-estudadas","text":"Para cada estrat\u00e9gia que vamos estudar, implementaremos um programa correspondente no projeto. Veja abaixo as datas de entrega e descri\u00e7\u00f5es de cada estrat\u00e9gia a ser implementada. Em geral, o enunciado de uma parte \u00e9 liberado ap\u00f3s a data de entrega da parte anterior. Solu\u00e7\u00e3o Heur\u00edstica (18/03) Busca Local (01/04) Busca Exaustiva (15/04) Relat\u00f3rio Preliminar (29/04) Paralelismo Multicore (13/05) Paralelismo GPU (27/05) Relat\u00f3rio Final (03/06)","title":"Estrat\u00e9gias a serem estudadas"},{"location":"projetos/#avaliacao","text":"O projeto ser\u00e1 avaliado usando rubricas para as entregas b\u00e1sicas. As rubricas de avalia\u00e7\u00e3o dos relat\u00f3rios estar\u00e3o descritas em suas p\u00e1ginas de entrega.","title":"Avalia\u00e7\u00e3o"},{"location":"projetos/#conceito-d","text":"Algum dos seguintes itens n\u00e3o foi entregue corretamente ou possui problemas s\u00e9rios (no caso do relat\u00f3rio final). Solu\u00e7\u00e3o heur\u00edstica Busca local Busca exaustiva Busca local paralela (CPU) Busca local paralela (GPU) Relat\u00f3rio preliminar Relat\u00f3rio final","title":"Conceito D"},{"location":"projetos/#conceito-c","text":"Todas as atividades abaixo foram validadas pelo corretor e (no caso do relat\u00f3rio final) alcan\u00e7aram qualidade m\u00ednima exigida. Solu\u00e7\u00e3o heur\u00edstica Busca local Busca exaustiva Busca local paralela (CPU) Busca local paralela (GPU) Relat\u00f3rio preliminar Relat\u00f3rio final","title":"Conceito C"},{"location":"projetos/#conceito-c_1","text":"Al\u00e9m do j\u00e1 validado no conceito C , os relat\u00f3rios entregues n\u00e3o tinham nenhum ponto em desenvolvimento ou insatisfat\u00f3rio na rubrica do relat\u00f3rio.","title":"Conceito C+"},{"location":"projetos/#conceitos-avancados","text":"A partir do conceito C+ cada atividade avan\u00e7ada vale meio conceito. Elas ser\u00e3o listadas aqui conforme o semestre avan\u00e7a e ser\u00e3o testadas pela checagem de resultados dispon\u00edvel no reposit\u00f3rio de entregas.","title":"Conceitos avan\u00e7ados"},{"location":"projetos/heuristico/","text":"Heur\u00edstica de Alinhamento Local de Smith-Waterman \u00b6 Um algoritmo ing\u00eanuo para fazer o alinhamento local de duas sequencias de DNA poderia ser: Gere todas as subsequ\u00eancias, de tamanho 1 at\u00e9 o tamanho total de cada sequ\u00eancia Compare todos os pares de subsequencias, sempre escolhendo uma subsequencia de um DNA e do outro DNA, calculado seus scores Escolha uma que produza o score m\u00e1ximo Nao \u00e9 dif\u00edcil ver que este algoritmo ing\u00eanuo pode demorar muito tempo para executar quando aumentamos o tamanho das sequencias de DNA. Uma heur\u00edstica sequencial bastante interessante para reduzir o tempo de obten\u00e7\u00e3o dos alinhamentos foi proposta por Smith e Waterman (1981), utilizando programa\u00e7\u00e3o din\u00e2mica. Abaixo, temos a descri\u00e7\u00e3o do algoritmo desta estrat\u00e9gia: ALGORITMO SMITH-WATERMAN Entrada: Duas sequencias de DNA a[i] e b[j], de tamanhos n e m respectivamente Sa\u00edda: score m\u00e1ximo de alinhamento 1. Inicializar H[i,0]=0, 0\u2264i\u2264n 2. Inicializar H[0,j]=0, 0\u2264j\u2264m 3. Para cada 1\u2264i\u2264n e 1\u2264j\u2264m: 4. Calcular diagonal = H[i-1,j-1] + w(a[i],b[j]), onde w(a[i],b[j])=2 se houve match, w(a[i],b[j])= -1 se houve mismatch e w(a[i],b[j])= -1 se houve gap 5. Calcular dele\u00e7\u00e3o = H[i-1,j] - 1 6. Calcular inser\u00e7\u00e3o = H[i,j-1] - 1 7. Calcular H[i,j]=m\u00e1ximo (0, diagonal, dele\u00e7\u00e3o, inser\u00e7\u00e3o) 9. Retornar o m\u00e1ximo de H[_,_] Os passos diagonal, dele\u00e7\u00e3o e inser\u00e7\u00e3o s\u00e3o chamados, respectivamente, de salto em diagonal, salto de cima para baixo e salto da esquerda para a direita, e representam movimenta\u00e7\u00f5es para obten\u00e7\u00e3o do alinhamento local \u00f3timo. No link abaixo, \u00e9 poss\u00edvel simular este algoritmo para diversos valores de pesos: http://rna.informatik.uni-freiburg.de/Teaching/index.jsp?toolName=Smith-Waterman Abaixo temos um exemplo da matriz H calculada para as sequ\u00eancias AGCACACA e ACACACTA: Para obter o alinhamento local \u00f3timo, come\u00e7amos com o maior valor na matriz (i,j). Ent\u00e3o, n\u00f3s vamos para tr\u00e1s para uma das posi\u00e7\u00f5es (i-1,j), (i,j-1) ou (i-1,j-1), dependendo da dire\u00e7\u00e3o de movimento usado para construir a matriz. Mantemos o processo at\u00e9 chegar a um c\u00e9lula da matriz com valor zero, ou o valor na posi\u00e7\u00e3o (0,0). No exemplo, o valor mais alto corresponde \u00e0 c\u00e9lula na posi\u00e7\u00e3o (8,8). A caminhada de volta corresponde a (8,8), (7,7), (7,6), (6,5), (5,4), (4,3), (3,2), (2,1), (1,1), e (0,0), Uma vez que tenhamos terminado, reconstruimos o alinhamento da seguinte forma: Come\u00e7ando com o \u00faltimo valor, chegamos a (i,j) usando o caminho previamente calculado. Um salto na diagonal implica que h\u00e1 um alinhamento (ou uma correspond\u00eancia ou uma n\u00e3o correspond\u00eancia). Um salto de cima para baixo implica que h\u00e1 uma dele\u00e7\u00e3o. Um salto da esquerda para a direita implica que h\u00e1 uma inser\u00e7\u00e3o. Assim, para a reconstru\u00e7\u00e3o, \u00e9 importante guardar durante a montagem da tabela H qual o tipo de salto foi utilizado. Para o exemplo das sequencias acima, obtemos o seguinte alinhamento local \u00f3timo (em rela\u00e7\u00e3o aos pesos dados para match, mismatch e gap): Sequ\u00eancia 1 = A-CACACTA Sequ\u00eancia 2 = AGCACAC-A A partir desta descri\u00e7\u00e3o, nosso primeiro projeto ter\u00e1 duas tarefas: Implementar um programa C++ para ler um arquivo contendo os tamanhos de duas sequencias de DNA, seguidos das duas sequencias, uma por linha. Calcular o score m\u00e1ximo de alinhamento local usando a heur\u00edstica de Smith-Waterman. As informa\u00e7\u00f5es para reconstru\u00e7\u00e3o dever\u00e3o ser armazenadas no formato de struct. a partir do score m\u00e1ximo, reconstruir e exibir o alinhamento local \u00f3timo das duas sequencias. No diret\u00f3rio do projeto, h\u00e1 um gerador de entradas disponibilizado como um notebook Python. Para quem estiver interessado no artigo original da heur\u00edstica de Smith-Waterman, basta consultar o link http://arep.med.harvard.edu/pdf/Smith81.pdf .","title":"Heur\u00edstica de Alinhamento Local de Smith-Waterman"},{"location":"projetos/heuristico/#heuristica-de-alinhamento-local-de-smith-waterman","text":"Um algoritmo ing\u00eanuo para fazer o alinhamento local de duas sequencias de DNA poderia ser: Gere todas as subsequ\u00eancias, de tamanho 1 at\u00e9 o tamanho total de cada sequ\u00eancia Compare todos os pares de subsequencias, sempre escolhendo uma subsequencia de um DNA e do outro DNA, calculado seus scores Escolha uma que produza o score m\u00e1ximo Nao \u00e9 dif\u00edcil ver que este algoritmo ing\u00eanuo pode demorar muito tempo para executar quando aumentamos o tamanho das sequencias de DNA. Uma heur\u00edstica sequencial bastante interessante para reduzir o tempo de obten\u00e7\u00e3o dos alinhamentos foi proposta por Smith e Waterman (1981), utilizando programa\u00e7\u00e3o din\u00e2mica. Abaixo, temos a descri\u00e7\u00e3o do algoritmo desta estrat\u00e9gia: ALGORITMO SMITH-WATERMAN Entrada: Duas sequencias de DNA a[i] e b[j], de tamanhos n e m respectivamente Sa\u00edda: score m\u00e1ximo de alinhamento 1. Inicializar H[i,0]=0, 0\u2264i\u2264n 2. Inicializar H[0,j]=0, 0\u2264j\u2264m 3. Para cada 1\u2264i\u2264n e 1\u2264j\u2264m: 4. Calcular diagonal = H[i-1,j-1] + w(a[i],b[j]), onde w(a[i],b[j])=2 se houve match, w(a[i],b[j])= -1 se houve mismatch e w(a[i],b[j])= -1 se houve gap 5. Calcular dele\u00e7\u00e3o = H[i-1,j] - 1 6. Calcular inser\u00e7\u00e3o = H[i,j-1] - 1 7. Calcular H[i,j]=m\u00e1ximo (0, diagonal, dele\u00e7\u00e3o, inser\u00e7\u00e3o) 9. Retornar o m\u00e1ximo de H[_,_] Os passos diagonal, dele\u00e7\u00e3o e inser\u00e7\u00e3o s\u00e3o chamados, respectivamente, de salto em diagonal, salto de cima para baixo e salto da esquerda para a direita, e representam movimenta\u00e7\u00f5es para obten\u00e7\u00e3o do alinhamento local \u00f3timo. No link abaixo, \u00e9 poss\u00edvel simular este algoritmo para diversos valores de pesos: http://rna.informatik.uni-freiburg.de/Teaching/index.jsp?toolName=Smith-Waterman Abaixo temos um exemplo da matriz H calculada para as sequ\u00eancias AGCACACA e ACACACTA: Para obter o alinhamento local \u00f3timo, come\u00e7amos com o maior valor na matriz (i,j). Ent\u00e3o, n\u00f3s vamos para tr\u00e1s para uma das posi\u00e7\u00f5es (i-1,j), (i,j-1) ou (i-1,j-1), dependendo da dire\u00e7\u00e3o de movimento usado para construir a matriz. Mantemos o processo at\u00e9 chegar a um c\u00e9lula da matriz com valor zero, ou o valor na posi\u00e7\u00e3o (0,0). No exemplo, o valor mais alto corresponde \u00e0 c\u00e9lula na posi\u00e7\u00e3o (8,8). A caminhada de volta corresponde a (8,8), (7,7), (7,6), (6,5), (5,4), (4,3), (3,2), (2,1), (1,1), e (0,0), Uma vez que tenhamos terminado, reconstruimos o alinhamento da seguinte forma: Come\u00e7ando com o \u00faltimo valor, chegamos a (i,j) usando o caminho previamente calculado. Um salto na diagonal implica que h\u00e1 um alinhamento (ou uma correspond\u00eancia ou uma n\u00e3o correspond\u00eancia). Um salto de cima para baixo implica que h\u00e1 uma dele\u00e7\u00e3o. Um salto da esquerda para a direita implica que h\u00e1 uma inser\u00e7\u00e3o. Assim, para a reconstru\u00e7\u00e3o, \u00e9 importante guardar durante a montagem da tabela H qual o tipo de salto foi utilizado. Para o exemplo das sequencias acima, obtemos o seguinte alinhamento local \u00f3timo (em rela\u00e7\u00e3o aos pesos dados para match, mismatch e gap): Sequ\u00eancia 1 = A-CACACTA Sequ\u00eancia 2 = AGCACAC-A A partir desta descri\u00e7\u00e3o, nosso primeiro projeto ter\u00e1 duas tarefas: Implementar um programa C++ para ler um arquivo contendo os tamanhos de duas sequencias de DNA, seguidos das duas sequencias, uma por linha. Calcular o score m\u00e1ximo de alinhamento local usando a heur\u00edstica de Smith-Waterman. As informa\u00e7\u00f5es para reconstru\u00e7\u00e3o dever\u00e3o ser armazenadas no formato de struct. a partir do score m\u00e1ximo, reconstruir e exibir o alinhamento local \u00f3timo das duas sequencias. No diret\u00f3rio do projeto, h\u00e1 um gerador de entradas disponibilizado como um notebook Python. Para quem estiver interessado no artigo original da heur\u00edstica de Smith-Waterman, basta consultar o link http://arep.med.harvard.edu/pdf/Smith81.pdf .","title":"Heur\u00edstica de Alinhamento Local de Smith-Waterman"},{"location":"projetos/local/","text":"Um algoritmo Local para Alinhamento \u00b6 Como vimos em aula, aleatoriedade \u00e9 uma estrat\u00e9gia bastante comum para constru\u00e7\u00e3o de algoritmos de busca local, podendo ser usada de forma isolada ou de forma complementar a outra estrat\u00e9gia de varredura de um espa\u00e7o de solu\u00e7\u00f5es. Em problemas de alinhamento, varreduras suportadas por aleatoriedade tem produzido algoritmos bastante efetivos. Dentro deste contexto, vamos considerar o algoritmo proposto abaixo: ALGORITMO BUSCA LOCAL COM ALEATORIEDADE Entrada: Duas sequencias de DNA a[i] e b[j], de tamanhos n e m respectivamente,pesos wmat, wmis e wgap para match, mismatch e gap respectivamente Sa\u00edda: Score de um alinhamento das sequencias Subsequencias alinhadas 1. Gerar uma subsequencia sb=b[j,j+1,...,j+k] de b, de tamanho aleat\u00f3rio k, 1<=k<=m, e 0<=j<=m 2. Gerar um n\u00famero aleat\u00f3rio inteiro positivo p 3. Gerar p subsequencias sa=a[i,i+1,...,i+k] de a, com tamanho k calculado no passo (1), 0<=i<=n 4. Calcular os scores de cada par (sa,sb) com os pesos wmat, wmis e wgap 5. Devolver o score m\u00e1ximo m entre os scores do passo (4) e as subsequencias associadas a ele A partir desta descri\u00e7\u00e3o, nosso primeiro projeto ter\u00e1 duas tarefas: Implementar um programa C++ para ler um arquivo contendo os tamanhos de duas sequencias de DNA, seguidos das duas sequencias, uma por linha. Calcular o score m\u00e1ximo utilizando o algoritmo acima, assim como as subsequencias associadas a ele. Testar o algoritmo diversas vezes e comparar seus resultados com a heur\u00edstica do primeiro projeto observando, principalmente, o seu comportamento em rela\u00e7\u00e3o aos valores aleat\u00f3rios k e p. Estes resultados e sua compara\u00e7\u00e3o dever\u00e3o estar presentes no relat\u00f3rio a ser entregue posteriormente. No diret\u00f3rio do projeto, h\u00e1 um gerador de entradas disponibilizado como um notebook Python.","title":"Um algoritmo Local para Alinhamento"},{"location":"projetos/local/#um-algoritmo-local-para-alinhamento","text":"Como vimos em aula, aleatoriedade \u00e9 uma estrat\u00e9gia bastante comum para constru\u00e7\u00e3o de algoritmos de busca local, podendo ser usada de forma isolada ou de forma complementar a outra estrat\u00e9gia de varredura de um espa\u00e7o de solu\u00e7\u00f5es. Em problemas de alinhamento, varreduras suportadas por aleatoriedade tem produzido algoritmos bastante efetivos. Dentro deste contexto, vamos considerar o algoritmo proposto abaixo: ALGORITMO BUSCA LOCAL COM ALEATORIEDADE Entrada: Duas sequencias de DNA a[i] e b[j], de tamanhos n e m respectivamente,pesos wmat, wmis e wgap para match, mismatch e gap respectivamente Sa\u00edda: Score de um alinhamento das sequencias Subsequencias alinhadas 1. Gerar uma subsequencia sb=b[j,j+1,...,j+k] de b, de tamanho aleat\u00f3rio k, 1<=k<=m, e 0<=j<=m 2. Gerar um n\u00famero aleat\u00f3rio inteiro positivo p 3. Gerar p subsequencias sa=a[i,i+1,...,i+k] de a, com tamanho k calculado no passo (1), 0<=i<=n 4. Calcular os scores de cada par (sa,sb) com os pesos wmat, wmis e wgap 5. Devolver o score m\u00e1ximo m entre os scores do passo (4) e as subsequencias associadas a ele A partir desta descri\u00e7\u00e3o, nosso primeiro projeto ter\u00e1 duas tarefas: Implementar um programa C++ para ler um arquivo contendo os tamanhos de duas sequencias de DNA, seguidos das duas sequencias, uma por linha. Calcular o score m\u00e1ximo utilizando o algoritmo acima, assim como as subsequencias associadas a ele. Testar o algoritmo diversas vezes e comparar seus resultados com a heur\u00edstica do primeiro projeto observando, principalmente, o seu comportamento em rela\u00e7\u00e3o aos valores aleat\u00f3rios k e p. Estes resultados e sua compara\u00e7\u00e3o dever\u00e3o estar presentes no relat\u00f3rio a ser entregue posteriormente. No diret\u00f3rio do projeto, h\u00e1 um gerador de entradas disponibilizado como um notebook Python.","title":"Um algoritmo Local para Alinhamento"},{"location":"projetos/2021-2/","text":"Alinhamento de Sequencias de DNA \u00b6 Em Bioinform\u00e1tica, o problema de alinhamento de sequ\u00eancias de DNA consiste no processo de comparar duas ou mais sequ\u00eancias de bases de forma a se observar seu n\u00edvel de similaridade. Trata-se de um problema extremamente importante no contexto atual, pois permite comparar sequencias virais de SARS-COV2 em bancos de dados gen\u00f4micos para detec\u00e7\u00e3o de novas muta\u00e7\u00f5es. O n\u00edvel de similaridade pode ser calculado com base em acertos (match) e erros (gap e mismatch) . Os acertos contribuem com sinal positivo (+) para o n\u00edvel de similaridade e, os erros, com sinal negativo (-). Abaixo temos um exemplo de c\u00e1lculo do n\u00edvel similaridade: Vamos associar a pontua\u00e7\u00e3o +1 (match) e as penalidades -1 (gap) e -4 (mismatch) . Assim, teremos o seguinte n\u00edvel de similaridade: 23 matches x (+1) + 4 gaps x (-1) + 3 mismatches x (-4) = 23-4-12 = 7 Neste contexto, o problema de alinhamento de sequencias de DNA pode ser colocado da seguinte forma: Dadas duas sequencias de DNA, com as bases A,T,G,C e - para indicar gap, encontrar o alinhamento que maximize o n\u00edvel de similaridade. Neste projeto, seu objetivo ser\u00e1 construir programas para encontrar este alinhamento de n\u00edvel m\u00e1ximo de similaridade, utilizando v\u00e1rias estrat\u00e9gias. Cada um dos seus programas tomar\u00e1 como entrada a seguinte estrutura: a primeira linha cont\u00e9m dois n\u00fameros n e m , onde n \u00e9 o tamanho da primeira sequencia e, m , o tamanho da segunda. Assuma n \u2264 200 e m \u2264 200 . A segunda linha cont\u00e9m as bases da primeira sequencia e, a terceira linha, as bases da segunda. 5 7 AT-CC TTTCCAA A sa\u00edda deve ser uma linha com um n\u00famero inteiro indicando o n\u00edvel m\u00e1ximo de similaridade. 2 Neste caso, este n\u00edvel m\u00e1ximo de similaridade pode ser associado ao alinhamento T-CC/TTCC (1-1+1+1=2) ou a CC/CC(1+1=2). Voc\u00ea pode usar o c\u00f3digo python abaixo para gerar inst\u00e2ncias aleat\u00f3rias para seus testes. import random n = 10 # tamanho da primeira sequ\u00eancia m = 40 # tamanho da segunda sequ\u00eancia file = 'dna.seq' # nome do arquivo a ser gerado f = open ( file , 'w' ) seq = [ str ( n ) + ' \\n ' , str ( m ) + ' \\n ' , '' . join ( random . choices ([ 'A' , 'T' , 'C' , 'G' , '-' ], k = n )) + ' \\n ' , '' . join ( random . choices ([ 'A' , 'T' , 'C' , 'G' , '-' ], k = m ))] f . writelines ( seq ) f . close () print ( '' . join ( seq )) Um poss\u00edvel output para este c\u00f3digo acima \u00e9: 10 40 TGGCGAT--C AGC-TCTCTTC--ATT--CAC-TACACCGACA-CGC-G-A Estrat\u00e9gias a serem estudadas e corre\u00e7\u00e3o autom\u00e1tica \u00b6 Para cada estrat\u00e9gia que vamos estudar, implementaremos um programa correspondente no projeto. Veja abaixo as datas de entrega e descri\u00e7\u00f5es de cada estrat\u00e9gia a ser implementada. Em geral, o enunciado de uma parte \u00e9 liberado ap\u00f3s a data de entrega da parte anterior. Solu\u00e7\u00e3o Heur\u00edstica (18/03) Busca Local (01/04) Busca Exaustiva (15/04) Relat\u00f3rio Preliminar (29/04) Paralelismo Multicore (13/05) Paralelismo GPU (27/05) Relat\u00f3rio Final (03/06) Avalia\u00e7\u00e3o \u00b6 O projeto ser\u00e1 avaliado usando rubricas para as entregas b\u00e1sicas. As rubricas de avalia\u00e7\u00e3o dos relat\u00f3rios estar\u00e3o descritas em suas p\u00e1ginas de entrega. Conceito D \u00b6 Algum dos seguintes itens n\u00e3o foi entregue corretamente ou possui problemas s\u00e9rios (no caso do relat\u00f3rio final). Solu\u00e7\u00e3o heur\u00edstica Busca local Busca exaustiva Busca local paralela (CPU) Busca local paralela (GPU) Relat\u00f3rio preliminar Relat\u00f3rio final Conceito C \u00b6 Todas as atividades abaixo foram validadas pelo corretor e (no caso do relat\u00f3rio final) alcan\u00e7aram qualidade m\u00ednima exigida. Solu\u00e7\u00e3o heur\u00edstica Busca local Busca exaustiva Busca local paralela (CPU) Busca local paralela (GPU) Relat\u00f3rio preliminar Relat\u00f3rio final Conceito C+ \u00b6 Al\u00e9m do j\u00e1 validado no conceito C , os relat\u00f3rios entregues n\u00e3o tinham nenhum ponto em desenvolvimento ou insatisfat\u00f3rio na rubrica do relat\u00f3rio. Conceitos avan\u00e7ados \u00b6 A partir do conceito C+ cada atividade avan\u00e7ada vale meio conceito. Elas ser\u00e3o listadas aqui conforme o semestre avan\u00e7a e ser\u00e3o testadas pela checagem de resultados dispon\u00edvel no reposit\u00f3rio de entregas.","title":"Alinhamento de Sequencias de DNA"},{"location":"projetos/2021-2/#alinhamento-de-sequencias-de-dna","text":"Em Bioinform\u00e1tica, o problema de alinhamento de sequ\u00eancias de DNA consiste no processo de comparar duas ou mais sequ\u00eancias de bases de forma a se observar seu n\u00edvel de similaridade. Trata-se de um problema extremamente importante no contexto atual, pois permite comparar sequencias virais de SARS-COV2 em bancos de dados gen\u00f4micos para detec\u00e7\u00e3o de novas muta\u00e7\u00f5es. O n\u00edvel de similaridade pode ser calculado com base em acertos (match) e erros (gap e mismatch) . Os acertos contribuem com sinal positivo (+) para o n\u00edvel de similaridade e, os erros, com sinal negativo (-). Abaixo temos um exemplo de c\u00e1lculo do n\u00edvel similaridade: Vamos associar a pontua\u00e7\u00e3o +1 (match) e as penalidades -1 (gap) e -4 (mismatch) . Assim, teremos o seguinte n\u00edvel de similaridade: 23 matches x (+1) + 4 gaps x (-1) + 3 mismatches x (-4) = 23-4-12 = 7 Neste contexto, o problema de alinhamento de sequencias de DNA pode ser colocado da seguinte forma: Dadas duas sequencias de DNA, com as bases A,T,G,C e - para indicar gap, encontrar o alinhamento que maximize o n\u00edvel de similaridade. Neste projeto, seu objetivo ser\u00e1 construir programas para encontrar este alinhamento de n\u00edvel m\u00e1ximo de similaridade, utilizando v\u00e1rias estrat\u00e9gias. Cada um dos seus programas tomar\u00e1 como entrada a seguinte estrutura: a primeira linha cont\u00e9m dois n\u00fameros n e m , onde n \u00e9 o tamanho da primeira sequencia e, m , o tamanho da segunda. Assuma n \u2264 200 e m \u2264 200 . A segunda linha cont\u00e9m as bases da primeira sequencia e, a terceira linha, as bases da segunda. 5 7 AT-CC TTTCCAA A sa\u00edda deve ser uma linha com um n\u00famero inteiro indicando o n\u00edvel m\u00e1ximo de similaridade. 2 Neste caso, este n\u00edvel m\u00e1ximo de similaridade pode ser associado ao alinhamento T-CC/TTCC (1-1+1+1=2) ou a CC/CC(1+1=2). Voc\u00ea pode usar o c\u00f3digo python abaixo para gerar inst\u00e2ncias aleat\u00f3rias para seus testes. import random n = 10 # tamanho da primeira sequ\u00eancia m = 40 # tamanho da segunda sequ\u00eancia file = 'dna.seq' # nome do arquivo a ser gerado f = open ( file , 'w' ) seq = [ str ( n ) + ' \\n ' , str ( m ) + ' \\n ' , '' . join ( random . choices ([ 'A' , 'T' , 'C' , 'G' , '-' ], k = n )) + ' \\n ' , '' . join ( random . choices ([ 'A' , 'T' , 'C' , 'G' , '-' ], k = m ))] f . writelines ( seq ) f . close () print ( '' . join ( seq )) Um poss\u00edvel output para este c\u00f3digo acima \u00e9: 10 40 TGGCGAT--C AGC-TCTCTTC--ATT--CAC-TACACCGACA-CGC-G-A","title":"Alinhamento de Sequencias de DNA"},{"location":"projetos/2021-2/#estrategias-a-serem-estudadas-e-correcao-automatica","text":"Para cada estrat\u00e9gia que vamos estudar, implementaremos um programa correspondente no projeto. Veja abaixo as datas de entrega e descri\u00e7\u00f5es de cada estrat\u00e9gia a ser implementada. Em geral, o enunciado de uma parte \u00e9 liberado ap\u00f3s a data de entrega da parte anterior. Solu\u00e7\u00e3o Heur\u00edstica (18/03) Busca Local (01/04) Busca Exaustiva (15/04) Relat\u00f3rio Preliminar (29/04) Paralelismo Multicore (13/05) Paralelismo GPU (27/05) Relat\u00f3rio Final (03/06)","title":"Estrat\u00e9gias a serem estudadas e corre\u00e7\u00e3o autom\u00e1tica"},{"location":"projetos/2021-2/#avaliacao","text":"O projeto ser\u00e1 avaliado usando rubricas para as entregas b\u00e1sicas. As rubricas de avalia\u00e7\u00e3o dos relat\u00f3rios estar\u00e3o descritas em suas p\u00e1ginas de entrega.","title":"Avalia\u00e7\u00e3o"},{"location":"projetos/2021-2/#conceito-d","text":"Algum dos seguintes itens n\u00e3o foi entregue corretamente ou possui problemas s\u00e9rios (no caso do relat\u00f3rio final). Solu\u00e7\u00e3o heur\u00edstica Busca local Busca exaustiva Busca local paralela (CPU) Busca local paralela (GPU) Relat\u00f3rio preliminar Relat\u00f3rio final","title":"Conceito D"},{"location":"projetos/2021-2/#conceito-c","text":"Todas as atividades abaixo foram validadas pelo corretor e (no caso do relat\u00f3rio final) alcan\u00e7aram qualidade m\u00ednima exigida. Solu\u00e7\u00e3o heur\u00edstica Busca local Busca exaustiva Busca local paralela (CPU) Busca local paralela (GPU) Relat\u00f3rio preliminar Relat\u00f3rio final","title":"Conceito C"},{"location":"projetos/2021-2/#conceito-c_1","text":"Al\u00e9m do j\u00e1 validado no conceito C , os relat\u00f3rios entregues n\u00e3o tinham nenhum ponto em desenvolvimento ou insatisfat\u00f3rio na rubrica do relat\u00f3rio.","title":"Conceito C+"},{"location":"projetos/2021-2/#conceitos-avancados","text":"A partir do conceito C+ cada atividade avan\u00e7ada vale meio conceito. Elas ser\u00e3o listadas aqui conforme o semestre avan\u00e7a e ser\u00e3o testadas pela checagem de resultados dispon\u00edvel no reposit\u00f3rio de entregas.","title":"Conceitos avan\u00e7ados"},{"location":"projetos/2021-2/busca-exaustiva/","text":"Solu\u00e7\u00e3o Busca exaustiva - Branch and Bound \u00b6 Fa\u00e7a agora uma implementa\u00e7\u00e3o de busca exaustiva para o problema do min-set-cover. Assuma inicialmente que todos os subconjuntos s\u00e3o necess\u00e1rios. Para cada subconjunto da solu\u00e7\u00e3o, remova ele a solu\u00e7\u00e3o em quest\u00e3o e verifique se a propriedade de cobertura \u00e9 mantida. Fa\u00e7a isso para todos os elementos na ordem do vetor de solu\u00e7\u00f5es, enquanto a propriedade for v\u00e1lida. Se a propriedade ficar inv\u00e1lida, voc\u00ea deve interromper essa linha de processamento, executando ent\u00e3o uma nova estrutura de possibilidades em que considera esse conjunto vital para a continuidade do problema. Para auxiliar na sua implementa\u00e7\u00e3o, voc\u00ea pode se basear no pseudoc\u00f3digo abaixo. Assuma que custos \u00e9 um vetor unit\u00e1rio de cardinalidade igual ao vetor que armazena os subconjuntos. H\u00e1 um programa Python disponibilizado neste link para que voc\u00ea possa simular a implementa\u00e7\u00e3o desse pseudoc\u00f3digo. Avalie: H\u00e1 garantia de que o resultado \u00f3timo \u00e9 obtido? Justifique.","title":"Solu\u00e7\u00e3o Busca exaustiva - Branch and Bound"},{"location":"projetos/2021-2/busca-exaustiva/#solucao-busca-exaustiva-branch-and-bound","text":"Fa\u00e7a agora uma implementa\u00e7\u00e3o de busca exaustiva para o problema do min-set-cover. Assuma inicialmente que todos os subconjuntos s\u00e3o necess\u00e1rios. Para cada subconjunto da solu\u00e7\u00e3o, remova ele a solu\u00e7\u00e3o em quest\u00e3o e verifique se a propriedade de cobertura \u00e9 mantida. Fa\u00e7a isso para todos os elementos na ordem do vetor de solu\u00e7\u00f5es, enquanto a propriedade for v\u00e1lida. Se a propriedade ficar inv\u00e1lida, voc\u00ea deve interromper essa linha de processamento, executando ent\u00e3o uma nova estrutura de possibilidades em que considera esse conjunto vital para a continuidade do problema. Para auxiliar na sua implementa\u00e7\u00e3o, voc\u00ea pode se basear no pseudoc\u00f3digo abaixo. Assuma que custos \u00e9 um vetor unit\u00e1rio de cardinalidade igual ao vetor que armazena os subconjuntos. H\u00e1 um programa Python disponibilizado neste link para que voc\u00ea possa simular a implementa\u00e7\u00e3o desse pseudoc\u00f3digo. Avalie: H\u00e1 garantia de que o resultado \u00f3timo \u00e9 obtido? Justifique.","title":"Solu\u00e7\u00e3o Busca exaustiva - Branch and Bound"},{"location":"projetos/2021-2/busca-local/","text":"Solu\u00e7\u00e3o Busca local \u00b6 A busca local consiste em uma metaheur\u00edstica usada para resolver problemas de otimiza\u00e7\u00e3o computacionalmente dif\u00edceis. Esse tipo de algoritmo percorre o espa\u00e7o de busca movendo-se iterativamente de uma solu\u00e7\u00e3o candidata para outra, seguindo um caminho atrav\u00e9s da rela\u00e7\u00e3o de vizinhan\u00e7a, at\u00e9 que uma solu\u00e7\u00e3o considerada boa o suficiente seja encontrada ou um limite de tempo decorrido. Normalmente todo candidato possui mais de uma solu\u00e7\u00e3o de vizinho e a escolha entre elas \u00e9 feita com o aux\u00edlio de informa\u00e7\u00f5es locais e experi\u00eancia anterior. A solu\u00e7\u00e3o por busca local tenta maximizar o n\u00famero de elementos com o m\u00ednimo de subconjuntos poss\u00edvel. Precisamos capturar esse crit\u00e9rio por meio de uma fun\u00e7\u00e3o de fitness . Uma maneira poss\u00edvel de fazer isso \u00e9 construir uma fun\u00e7\u00e3o de fitness calculando o n\u00famero de elementos capturados pelos subconjuntos de uma solu\u00e7\u00e3o candidata e, em seguida, dividindo-o pelo n\u00famero de subconjuntos que cont\u00e9m. Essa fun\u00e7\u00e3o de pontua\u00e7\u00e3o favorecer\u00e1 as solu\u00e7\u00f5es que acumulam a maioria dos elementos do universo U com o m\u00ednimo de subconjuntos. Para isso, implemente as seguintes altera\u00e7\u00f5es em seu projeto: Gerar uma solu\u00e7\u00e3o aleat\u00f3ria para o problema do min-set-cover; Percorra novamente os conjuntos os elementos da sua solu\u00e7\u00e3o e, de maneira rand\u00f4mica, troque at\u00e9 r (r entre 1 e 3) elementos da sua solu\u00e7\u00e3o por subconjuntos que ficaram de fora da solu\u00e7\u00e3o. Se a solu\u00e7\u00e3o tiver melhor escore, mantenha ela. Para verificar o desempenho, construa um cen\u00e1rio com ao menos 200 elementos e 80 subconjuntos, de at\u00e9 40 elementos cada. Fa\u00e7a tr\u00eas varia\u00e7\u00f5es desse cen\u00e1rio (elementos, subconjuntos, n\u00famero de elementos em subconjuntos) e avalie o desempenho e a efetividade em encontrar uma solu\u00e7\u00e3o \u00f3tima. Para a entrega, usaremos o site codePost , voc\u00ea recebeu na sala de aula o link para criar sua conta. A submiss\u00e3o ser\u00e1 feita unicamente por ele. Caso tenha alguma d\u00favida, entre em contato.","title":"Solu\u00e7\u00e3o Busca local"},{"location":"projetos/2021-2/busca-local/#solucao-busca-local","text":"A busca local consiste em uma metaheur\u00edstica usada para resolver problemas de otimiza\u00e7\u00e3o computacionalmente dif\u00edceis. Esse tipo de algoritmo percorre o espa\u00e7o de busca movendo-se iterativamente de uma solu\u00e7\u00e3o candidata para outra, seguindo um caminho atrav\u00e9s da rela\u00e7\u00e3o de vizinhan\u00e7a, at\u00e9 que uma solu\u00e7\u00e3o considerada boa o suficiente seja encontrada ou um limite de tempo decorrido. Normalmente todo candidato possui mais de uma solu\u00e7\u00e3o de vizinho e a escolha entre elas \u00e9 feita com o aux\u00edlio de informa\u00e7\u00f5es locais e experi\u00eancia anterior. A solu\u00e7\u00e3o por busca local tenta maximizar o n\u00famero de elementos com o m\u00ednimo de subconjuntos poss\u00edvel. Precisamos capturar esse crit\u00e9rio por meio de uma fun\u00e7\u00e3o de fitness . Uma maneira poss\u00edvel de fazer isso \u00e9 construir uma fun\u00e7\u00e3o de fitness calculando o n\u00famero de elementos capturados pelos subconjuntos de uma solu\u00e7\u00e3o candidata e, em seguida, dividindo-o pelo n\u00famero de subconjuntos que cont\u00e9m. Essa fun\u00e7\u00e3o de pontua\u00e7\u00e3o favorecer\u00e1 as solu\u00e7\u00f5es que acumulam a maioria dos elementos do universo U com o m\u00ednimo de subconjuntos. Para isso, implemente as seguintes altera\u00e7\u00f5es em seu projeto: Gerar uma solu\u00e7\u00e3o aleat\u00f3ria para o problema do min-set-cover; Percorra novamente os conjuntos os elementos da sua solu\u00e7\u00e3o e, de maneira rand\u00f4mica, troque at\u00e9 r (r entre 1 e 3) elementos da sua solu\u00e7\u00e3o por subconjuntos que ficaram de fora da solu\u00e7\u00e3o. Se a solu\u00e7\u00e3o tiver melhor escore, mantenha ela. Para verificar o desempenho, construa um cen\u00e1rio com ao menos 200 elementos e 80 subconjuntos, de at\u00e9 40 elementos cada. Fa\u00e7a tr\u00eas varia\u00e7\u00f5es desse cen\u00e1rio (elementos, subconjuntos, n\u00famero de elementos em subconjuntos) e avalie o desempenho e a efetividade em encontrar uma solu\u00e7\u00e3o \u00f3tima. Para a entrega, usaremos o site codePost , voc\u00ea recebeu na sala de aula o link para criar sua conta. A submiss\u00e3o ser\u00e1 feita unicamente por ele. Caso tenha alguma d\u00favida, entre em contato.","title":"Solu\u00e7\u00e3o Busca local"},{"location":"projetos/2021-2/heuristico/","text":"Solu\u00e7\u00e3o heur\u00edstica \u00b6 Um dos melhores estrat\u00e9gias para resolu\u00e7\u00e3o do problema min-set-cover \u00e9 a estrat\u00e9gia gulosa. O algoritmo guloso encontra uma solu\u00e7\u00e3o para o problema de cobertura de conjunto escolhendo iterativamente um conjunto que cobre o maior n\u00famero poss\u00edvel de vari\u00e1veis descobertas restantes. Sua tarefa: implemente a estrat\u00e9gia gulosa para o problema do min-set-cover. A cada itera\u00e7\u00e3o, o algoritmo deve selecionar o subconjunto de F que ir\u00e1 cobrir o maior n\u00famero de elementos de U que estavam descobertos . Veja abaixo um pseudo-c\u00f3digo da estrat\u00e9gia gulosa que voc\u00ea deve implementar. Fa\u00e7a testes para diversos tipos de entradas, e foque principalmente em uma grande quantidade de elementos e subconjuntos (n > 250). Voc\u00ea deve entregar, al\u00e9m de c\u00f3digo-fonte e todas as entradas e sa\u00eddas geradas para o seu programa, um arquivo contendo o resultado do programa verify ( que voc\u00ea implementou ) e comentar sobre o n\u00famero de vezes em que voc\u00ea conseguiu encontrar uma solu\u00e7\u00e3o para o problema. Comente tamb\u00e9m sobre o tempo de execu\u00e7\u00e3o de sua implementa\u00e7\u00e3o. Para a entrega, usaremos o site codePost , voc\u00ea recebeu na sala de aula o link para criar sua conta. A submiss\u00e3o ser\u00e1 feita unicamente por ele. Caso tenha alguma d\u00favida, entre em contato.","title":"Solu\u00e7\u00e3o heur\u00edstica"},{"location":"projetos/2021-2/heuristico/#solucao-heuristica","text":"Um dos melhores estrat\u00e9gias para resolu\u00e7\u00e3o do problema min-set-cover \u00e9 a estrat\u00e9gia gulosa. O algoritmo guloso encontra uma solu\u00e7\u00e3o para o problema de cobertura de conjunto escolhendo iterativamente um conjunto que cobre o maior n\u00famero poss\u00edvel de vari\u00e1veis descobertas restantes. Sua tarefa: implemente a estrat\u00e9gia gulosa para o problema do min-set-cover. A cada itera\u00e7\u00e3o, o algoritmo deve selecionar o subconjunto de F que ir\u00e1 cobrir o maior n\u00famero de elementos de U que estavam descobertos . Veja abaixo um pseudo-c\u00f3digo da estrat\u00e9gia gulosa que voc\u00ea deve implementar. Fa\u00e7a testes para diversos tipos de entradas, e foque principalmente em uma grande quantidade de elementos e subconjuntos (n > 250). Voc\u00ea deve entregar, al\u00e9m de c\u00f3digo-fonte e todas as entradas e sa\u00eddas geradas para o seu programa, um arquivo contendo o resultado do programa verify ( que voc\u00ea implementou ) e comentar sobre o n\u00famero de vezes em que voc\u00ea conseguiu encontrar uma solu\u00e7\u00e3o para o problema. Comente tamb\u00e9m sobre o tempo de execu\u00e7\u00e3o de sua implementa\u00e7\u00e3o. Para a entrega, usaremos o site codePost , voc\u00ea recebeu na sala de aula o link para criar sua conta. A submiss\u00e3o ser\u00e1 feita unicamente por ele. Caso tenha alguma d\u00favida, entre em contato.","title":"Solu\u00e7\u00e3o heur\u00edstica"},{"location":"projetos/2021-2/paralelismo-gpu/","text":"Paralelismo em GPU \u00b6 Seu trabalho nesta atividade ser\u00e1 criar uma implementa\u00e7\u00e3o paralela em GPU do algoritmo de busca local. Compila\u00e7\u00e3o do programa \u00b6 Voc\u00ea dever\u00e1 colocar o c\u00f3digo de seu programa em um arquivo com extens\u00e3o .cu na pasta da busca local. Este programa ser\u00e1 compilado com nvcc -O3 . Para a entrega, usaremos o site codePost . \u2192","title":"Paralelismo em GPU"},{"location":"projetos/2021-2/paralelismo-gpu/#paralelismo-em-gpu","text":"Seu trabalho nesta atividade ser\u00e1 criar uma implementa\u00e7\u00e3o paralela em GPU do algoritmo de busca local.","title":"Paralelismo em GPU"},{"location":"projetos/2021-2/paralelismo-gpu/#compilacao-do-programa","text":"Voc\u00ea dever\u00e1 colocar o c\u00f3digo de seu programa em um arquivo com extens\u00e3o .cu na pasta da busca local. Este programa ser\u00e1 compilado com nvcc -O3 . Para a entrega, usaremos o site codePost . \u2192","title":"Compila\u00e7\u00e3o do programa"},{"location":"projetos/2021-2/paralelismo-multicore/","text":"Paralelismo multi-core \u00b6 Seu trabalho nesta atividade ser\u00e1 criar uma implementa\u00e7\u00e3o paralela do algoritmo de busca local. Compila\u00e7\u00e3o do programa \u00b6 Seu programa multi-core dever\u00e1 ser gerado a partir do mesmo c\u00f3digo fonte do sequencial. Ou seja, compilar com -fopenmp habilita o programa paralelo. Compilar sem essa flag obtem os resultados sequenciais. Caso seu programa use as chamadas do OpenMP para c\u00f3digos auxiliares (aloca\u00e7\u00e3o de mem\u00f3ria, etc), voc\u00ea pode checar se seu programa foi compilado com esta flag seguindo o exemplo abaixo. #ifdef _OPENMP // c\u00f3digo espec\u00edfico para multi-core aqui #else // c\u00f3digo espec\u00edfico para sequencia aqui #endif Para a entrega, usaremos o site codePost .","title":"Paralelismo multi-core"},{"location":"projetos/2021-2/paralelismo-multicore/#paralelismo-multi-core","text":"Seu trabalho nesta atividade ser\u00e1 criar uma implementa\u00e7\u00e3o paralela do algoritmo de busca local.","title":"Paralelismo multi-core"},{"location":"projetos/2021-2/paralelismo-multicore/#compilacao-do-programa","text":"Seu programa multi-core dever\u00e1 ser gerado a partir do mesmo c\u00f3digo fonte do sequencial. Ou seja, compilar com -fopenmp habilita o programa paralelo. Compilar sem essa flag obtem os resultados sequenciais. Caso seu programa use as chamadas do OpenMP para c\u00f3digos auxiliares (aloca\u00e7\u00e3o de mem\u00f3ria, etc), voc\u00ea pode checar se seu programa foi compilado com esta flag seguindo o exemplo abaixo. #ifdef _OPENMP // c\u00f3digo espec\u00edfico para multi-core aqui #else // c\u00f3digo espec\u00edfico para sequencia aqui #endif Para a entrega, usaremos o site codePost .","title":"Compila\u00e7\u00e3o do programa"},{"location":"projetos/2021-2/relatorio-1/","text":"Relat\u00f3rio - v1 \u00b6 Nesta primeira parte do relat\u00f3rio iremos analisar as implementa\u00e7\u00f5es j\u00e1 criadas com rela\u00e7\u00e3o a sua velocidade e qualidade da solu\u00e7\u00e3o. Os objetivos deste relat\u00f3rio s\u00e3o criar entradas de tamanho adequado para os prop\u00f3sitos dos testes estudar o efeito do n\u00famero de pessoas e do n\u00famero de objetos nas medidas de interesse (tempo e qualidade da solu\u00e7\u00e3o) comparar o desempenho dos algoritmos implementados at\u00e9 o momento em rela\u00e7\u00e3o a essas duas medidas. Seu trabalhou dever\u00e1 ser entregue como um arquivo PDF chamado relatorio-intermediario.pdf na pasta relatorios do reposit\u00f3rio. Ele poder\u00e1 ser gerado a partir de um Jupyter notebook (como feito na aula 01 ) ou usando a ferramenta pweave ( recomendado ). A rubrica de avalia\u00e7\u00e3o est\u00e1 dispon\u00edvel abaixo e tamb\u00e9m neste link . Data de entrega: 31/10/2021, pelo blackboard.","title":"Relat\u00f3rio - v1"},{"location":"projetos/2021-2/relatorio-1/#relatorio-v1","text":"Nesta primeira parte do relat\u00f3rio iremos analisar as implementa\u00e7\u00f5es j\u00e1 criadas com rela\u00e7\u00e3o a sua velocidade e qualidade da solu\u00e7\u00e3o. Os objetivos deste relat\u00f3rio s\u00e3o criar entradas de tamanho adequado para os prop\u00f3sitos dos testes estudar o efeito do n\u00famero de pessoas e do n\u00famero de objetos nas medidas de interesse (tempo e qualidade da solu\u00e7\u00e3o) comparar o desempenho dos algoritmos implementados at\u00e9 o momento em rela\u00e7\u00e3o a essas duas medidas. Seu trabalhou dever\u00e1 ser entregue como um arquivo PDF chamado relatorio-intermediario.pdf na pasta relatorios do reposit\u00f3rio. Ele poder\u00e1 ser gerado a partir de um Jupyter notebook (como feito na aula 01 ) ou usando a ferramenta pweave ( recomendado ). A rubrica de avalia\u00e7\u00e3o est\u00e1 dispon\u00edvel abaixo e tamb\u00e9m neste link . Data de entrega: 31/10/2021, pelo blackboard.","title":"Relat\u00f3rio - v1"},{"location":"projetos/2022-1/","text":"Alinhamento de Sequencias de DNA \u00b6 Em Bioinform\u00e1tica, o problema de alinhamento de sequ\u00eancias de DNA consiste no processo de comparar duas ou mais sequ\u00eancias de bases de forma a se observar seu n\u00edvel de similaridade. Trata-se de um problema extremamente importante no contexto atual, pois permite comparar sequencias virais de SARS-COV2 em bancos de dados gen\u00f4micos para detec\u00e7\u00e3o de novas muta\u00e7\u00f5es. O n\u00edvel de similaridade pode ser calculado com base em acertos (match) e erros (gap e mismatch) . Os acertos contribuem com sinal positivo (+) para o n\u00edvel de similaridade e, os erros, com sinal negativo (-). Abaixo temos um exemplo de c\u00e1lculo do n\u00edvel similaridade: Vamos associar a pontua\u00e7\u00e3o +1 (match) e as penalidades -1 (gap) e -4 (mismatch) . Assim, teremos o seguinte n\u00edvel de similaridade: 23 matches x (+1) + 4 gaps x (-1) + 3 mismatches x (-4) = 23-4-12 = 7 Neste contexto, o problema de alinhamento de sequencias de DNA pode ser colocado da seguinte forma: Dadas duas sequencias de DNA, com as bases A,T,G,C e - para indicar gap, encontrar o alinhamento que maximize o n\u00edvel de similaridade. Neste projeto, seu objetivo ser\u00e1 construir programas para encontrar este alinhamento de n\u00edvel m\u00e1ximo de similaridade, utilizando v\u00e1rias estrat\u00e9gias. Cada um dos seus programas tomar\u00e1 como entrada a seguinte estrutura: a primeira linha cont\u00e9m dois n\u00fameros n e m , onde n \u00e9 o tamanho da primeira sequencia e, m , o tamanho da segunda. Assuma n \u2264 200 e m \u2264 200 . A segunda linha cont\u00e9m as bases da primeira sequencia e, a terceira linha, as bases da segunda. 5 7 AT-CC TTTCCAA A sa\u00edda deve ser uma linha com um n\u00famero inteiro indicando o n\u00edvel m\u00e1ximo de similaridade. 2 Neste caso, este n\u00edvel m\u00e1ximo de similaridade pode ser associado ao alinhamento T-CC/TTCC (1-1+1+1=2) ou a CC/CC(1+1=2). Voc\u00ea pode usar o notebook SequenceGenerator.ipynb para gerar inst\u00e2ncias aleat\u00f3rias para seus testes. Estrat\u00e9gias a serem estudadas e corre\u00e7\u00e3o autom\u00e1tica \u00b6 Para cada estrat\u00e9gia que vamos estudar, implementaremos um programa correspondente no projeto. Veja abaixo as datas de entrega e descri\u00e7\u00f5es de cada estrat\u00e9gia a ser implementada. Em geral, o enunciado de uma parte \u00e9 liberado ap\u00f3s a data de entrega da parte anterior. Solu\u00e7\u00e3o Heur\u00edstica (18/03) Busca Local (01/04) Busca Exaustiva (15/04) Relat\u00f3rio Preliminar (29/04) Paralelismo Multicore (13/05) Paralelismo GPU (27/05) Relat\u00f3rio Final (03/06) Avalia\u00e7\u00e3o \u00b6 O projeto ser\u00e1 avaliado usando rubricas para as entregas b\u00e1sicas. As rubricas de avalia\u00e7\u00e3o dos relat\u00f3rios estar\u00e3o descritas em suas p\u00e1ginas de entrega. Conceito D \u00b6 Algum dos seguintes itens n\u00e3o foi entregue corretamente ou possui problemas s\u00e9rios (no caso do relat\u00f3rio final). Solu\u00e7\u00e3o heur\u00edstica Busca local Busca exaustiva Busca local paralela (CPU) Busca local paralela (GPU) Relat\u00f3rio preliminar Relat\u00f3rio final Conceito C \u00b6 Todas as atividades abaixo foram validadas pelo corretor e (no caso do relat\u00f3rio final) alcan\u00e7aram qualidade m\u00ednima exigida. Solu\u00e7\u00e3o heur\u00edstica Busca local Busca exaustiva Busca local paralela (CPU) Busca local paralela (GPU) Relat\u00f3rio preliminar Relat\u00f3rio final Conceito C+ \u00b6 Al\u00e9m do j\u00e1 validado no conceito C , os relat\u00f3rios entregues n\u00e3o tinham nenhum ponto em desenvolvimento ou insatisfat\u00f3rio na rubrica do relat\u00f3rio. Conceitos avan\u00e7ados \u00b6 A partir do conceito C+ cada atividade avan\u00e7ada vale meio conceito. Elas ser\u00e3o listadas aqui conforme o semestre avan\u00e7a e ser\u00e3o testadas pela checagem de resultados dispon\u00edvel no reposit\u00f3rio de entregas.","title":"Alinhamento de Sequencias de DNA"},{"location":"projetos/2022-1/#alinhamento-de-sequencias-de-dna","text":"Em Bioinform\u00e1tica, o problema de alinhamento de sequ\u00eancias de DNA consiste no processo de comparar duas ou mais sequ\u00eancias de bases de forma a se observar seu n\u00edvel de similaridade. Trata-se de um problema extremamente importante no contexto atual, pois permite comparar sequencias virais de SARS-COV2 em bancos de dados gen\u00f4micos para detec\u00e7\u00e3o de novas muta\u00e7\u00f5es. O n\u00edvel de similaridade pode ser calculado com base em acertos (match) e erros (gap e mismatch) . Os acertos contribuem com sinal positivo (+) para o n\u00edvel de similaridade e, os erros, com sinal negativo (-). Abaixo temos um exemplo de c\u00e1lculo do n\u00edvel similaridade: Vamos associar a pontua\u00e7\u00e3o +1 (match) e as penalidades -1 (gap) e -4 (mismatch) . Assim, teremos o seguinte n\u00edvel de similaridade: 23 matches x (+1) + 4 gaps x (-1) + 3 mismatches x (-4) = 23-4-12 = 7 Neste contexto, o problema de alinhamento de sequencias de DNA pode ser colocado da seguinte forma: Dadas duas sequencias de DNA, com as bases A,T,G,C e - para indicar gap, encontrar o alinhamento que maximize o n\u00edvel de similaridade. Neste projeto, seu objetivo ser\u00e1 construir programas para encontrar este alinhamento de n\u00edvel m\u00e1ximo de similaridade, utilizando v\u00e1rias estrat\u00e9gias. Cada um dos seus programas tomar\u00e1 como entrada a seguinte estrutura: a primeira linha cont\u00e9m dois n\u00fameros n e m , onde n \u00e9 o tamanho da primeira sequencia e, m , o tamanho da segunda. Assuma n \u2264 200 e m \u2264 200 . A segunda linha cont\u00e9m as bases da primeira sequencia e, a terceira linha, as bases da segunda. 5 7 AT-CC TTTCCAA A sa\u00edda deve ser uma linha com um n\u00famero inteiro indicando o n\u00edvel m\u00e1ximo de similaridade. 2 Neste caso, este n\u00edvel m\u00e1ximo de similaridade pode ser associado ao alinhamento T-CC/TTCC (1-1+1+1=2) ou a CC/CC(1+1=2). Voc\u00ea pode usar o notebook SequenceGenerator.ipynb para gerar inst\u00e2ncias aleat\u00f3rias para seus testes.","title":"Alinhamento de Sequencias de DNA"},{"location":"projetos/2022-1/#estrategias-a-serem-estudadas-e-correcao-automatica","text":"Para cada estrat\u00e9gia que vamos estudar, implementaremos um programa correspondente no projeto. Veja abaixo as datas de entrega e descri\u00e7\u00f5es de cada estrat\u00e9gia a ser implementada. Em geral, o enunciado de uma parte \u00e9 liberado ap\u00f3s a data de entrega da parte anterior. Solu\u00e7\u00e3o Heur\u00edstica (18/03) Busca Local (01/04) Busca Exaustiva (15/04) Relat\u00f3rio Preliminar (29/04) Paralelismo Multicore (13/05) Paralelismo GPU (27/05) Relat\u00f3rio Final (03/06)","title":"Estrat\u00e9gias a serem estudadas e corre\u00e7\u00e3o autom\u00e1tica"},{"location":"projetos/2022-1/#avaliacao","text":"O projeto ser\u00e1 avaliado usando rubricas para as entregas b\u00e1sicas. As rubricas de avalia\u00e7\u00e3o dos relat\u00f3rios estar\u00e3o descritas em suas p\u00e1ginas de entrega.","title":"Avalia\u00e7\u00e3o"},{"location":"projetos/2022-1/#conceito-d","text":"Algum dos seguintes itens n\u00e3o foi entregue corretamente ou possui problemas s\u00e9rios (no caso do relat\u00f3rio final). Solu\u00e7\u00e3o heur\u00edstica Busca local Busca exaustiva Busca local paralela (CPU) Busca local paralela (GPU) Relat\u00f3rio preliminar Relat\u00f3rio final","title":"Conceito D"},{"location":"projetos/2022-1/#conceito-c","text":"Todas as atividades abaixo foram validadas pelo corretor e (no caso do relat\u00f3rio final) alcan\u00e7aram qualidade m\u00ednima exigida. Solu\u00e7\u00e3o heur\u00edstica Busca local Busca exaustiva Busca local paralela (CPU) Busca local paralela (GPU) Relat\u00f3rio preliminar Relat\u00f3rio final","title":"Conceito C"},{"location":"projetos/2022-1/#conceito-c_1","text":"Al\u00e9m do j\u00e1 validado no conceito C , os relat\u00f3rios entregues n\u00e3o tinham nenhum ponto em desenvolvimento ou insatisfat\u00f3rio na rubrica do relat\u00f3rio.","title":"Conceito C+"},{"location":"projetos/2022-1/#conceitos-avancados","text":"A partir do conceito C+ cada atividade avan\u00e7ada vale meio conceito. Elas ser\u00e3o listadas aqui conforme o semestre avan\u00e7a e ser\u00e3o testadas pela checagem de resultados dispon\u00edvel no reposit\u00f3rio de entregas.","title":"Conceitos avan\u00e7ados"},{"location":"projetos/2022-1/SequenceGenerator/","text":"(function() { function addWidgetsRenderer() { var requireJsScript = document.createElement('script'); requireJsScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js'; var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var jupyterWidgetsScript = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} jupyterWidgetsScript.src = widgetRendererSrc; document.body.appendChild(requireJsScript); document.body.appendChild(jupyterWidgetsScript); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); GERADOR DE INST\u00c2NCIAS PARA COMPARA\u00c7\u00c3O DE SEQUENCIAS DE DNA Para usar este gerador, voc\u00ea deve fornecer tr\u00eas par\u00e2metros: n = tamanho da primeira sequencia m = tamanho da segunda inst\u00e2ncia file = nome do arquivo da inst\u00e2ncia a ser gerada import random n = 10 m = 40 file = 'dna.seq' f = open ( file , 'w' ) seq = [ str ( n ) + ' \\n ' , str ( m ) + ' \\n ' , '' . join ( random . choices ([ 'A' , 'T' , 'C' , 'G' , '-' ], k = n )) + ' \\n ' , '' . join ( random . choices ([ 'A' , 'T' , 'C' , 'G' , '-' ], k = m ))] f . writelines ( seq ) f . close () print ( '' . join ( seq )) 10 40 TGGCGAT--C AGC-TCTCTTC--ATT--CAC-TACACCGACA-CGC-G-A","title":"SequenceGenerator"},{"location":"projetos/2022-1/heuristico/","text":"Heur\u00edstica de Alinhamento Local de Smith-Waterman \u00b6 Um algoritmo ing\u00eanuo para fazer o alinhamento local de duas sequencias de DNA poderia ser: Gere todas as subsequ\u00eancias, de tamanho 1 at\u00e9 o tamanho total de cada sequ\u00eancia Compare todos os pares de subsequencias, sempre escolhendo uma subsequencia de um DNA e do outro DNA, calculado seus scores Escolha uma que produza o score m\u00e1ximo Nao \u00e9 dif\u00edcil ver que este algoritmo ing\u00eanuo pode demorar muito tempo para executar quando aumentamos o tamanho das sequencias de DNA. Uma heur\u00edstica sequencial bastante interessante para reduzir o tempo de obten\u00e7\u00e3o dos alinhamentos foi proposta por Smith e Waterman (1981), utilizando programa\u00e7\u00e3o din\u00e2mica. Abaixo, temos a descri\u00e7\u00e3o do algoritmo desta estrat\u00e9gia: ALGORITMO SMITH-WATERMAN Entrada: Duas sequencias de DNA a[i] e b[j], de tamanhos n e m respectivamente Sa\u00edda: score m\u00e1ximo de alinhamento 1. Inicializar H[i,0]=0, 0\u2264i\u2264n 2. Inicializar H[0,j]=0, 0\u2264j\u2264m 3. Para cada 1\u2264i\u2264n e 1\u2264j\u2264m: 4. Calcular diagonal = H[i-1,j-1] + w(a[i],b[j]), onde w(a[i],b[j])=2 se houve match, w(a[i],b[j])= -1 se houve mismatch e w(a[i],b[j])= -1 se houve gap 5. Calcular dele\u00e7\u00e3o = H[i-1,j] - 1 6. Calcular inser\u00e7\u00e3o = H[i,j-1] - 1 7. Calcular H[i,j]=m\u00e1ximo (0, diagonal, dele\u00e7\u00e3o, inser\u00e7\u00e3o) 9. Retornar o m\u00e1ximo de H[_,_] Os passos diagonal, dele\u00e7\u00e3o e inser\u00e7\u00e3o s\u00e3o chamados, respectivamente, de salto em diagonal, salto de cima para baixo e salto da esquerda para a direita, e representam movimenta\u00e7\u00f5es para obten\u00e7\u00e3o do alinhamento local \u00f3timo. No link abaixo, \u00e9 poss\u00edvel simular este algoritmo para diversos valores de pesos: http://rna.informatik.uni-freiburg.de/Teaching/index.jsp?toolName=Smith-Waterman Abaixo temos um exemplo da matriz H calculada para as sequ\u00eancias AGCACACA e ACACACTA: Para obter o alinhamento local \u00f3timo, come\u00e7amos com o maior valor na matriz (i,j). Ent\u00e3o, n\u00f3s vamos para tr\u00e1s para uma das posi\u00e7\u00f5es (i-1,j), (i,j-1) ou (i-1,j-1), dependendo da dire\u00e7\u00e3o de movimento usado para construir a matriz. Mantemos o processo at\u00e9 chegar a um c\u00e9lula da matriz com valor zero, ou o valor na posi\u00e7\u00e3o (0,0). No exemplo, o valor mais alto corresponde \u00e0 c\u00e9lula na posi\u00e7\u00e3o (8,8). A caminhada de volta corresponde a (8,8), (7,7), (7,6), (6,5), (5,4), (4,3), (3,2), (2,1), (1,1), e (0,0), Uma vez que tenhamos terminado, reconstruimos o alinhamento da seguinte forma: Come\u00e7ando com o \u00faltimo valor, chegamos a (i,j) usando o caminho previamente calculado. Um salto na diagonal implica que h\u00e1 um alinhamento (ou uma correspond\u00eancia ou uma n\u00e3o correspond\u00eancia). Um salto de cima para baixo implica que h\u00e1 uma dele\u00e7\u00e3o. Um salto da esquerda para a direita implica que h\u00e1 uma inser\u00e7\u00e3o. Assim, para a reconstru\u00e7\u00e3o, \u00e9 importante guardar durante a montagem da tabela H qual o tipo de salto foi utilizado. Para o exemplo das sequencias acima, obtemos o seguinte alinhamento local \u00f3timo (em rela\u00e7\u00e3o aos pesos dados para match, mismatch e gap): Sequ\u00eancia 1 = A-CACACTA Sequ\u00eancia 2 = AGCACAC-A A partir desta descri\u00e7\u00e3o, nosso primeiro projeto ter\u00e1 duas tarefas: Implementar um programa C++ para ler um arquivo contendo os tamanhos de duas sequencias de DNA, seguidos das duas sequencias, uma por linha. Calcular o score m\u00e1ximo de alinhamento local usando a heur\u00edstica de Smith-Waterman. As informa\u00e7\u00f5es para reconstru\u00e7\u00e3o dever\u00e3o ser armazenadas no formato de struct. a partir do score m\u00e1ximo, reconstruir e exibir o alinhamento local \u00f3timo das duas sequencias. No diret\u00f3rio do projeto, h\u00e1 um gerador de entradas disponibilizado como um notebook Python. Para quem estiver interessado no artigo original da heur\u00edstica de Smith-Waterman, basta consultar o link http://arep.med.harvard.edu/pdf/Smith81.pdf .","title":"Heur\u00edstica de Alinhamento Local de Smith-Waterman"},{"location":"projetos/2022-1/heuristico/#heuristica-de-alinhamento-local-de-smith-waterman","text":"Um algoritmo ing\u00eanuo para fazer o alinhamento local de duas sequencias de DNA poderia ser: Gere todas as subsequ\u00eancias, de tamanho 1 at\u00e9 o tamanho total de cada sequ\u00eancia Compare todos os pares de subsequencias, sempre escolhendo uma subsequencia de um DNA e do outro DNA, calculado seus scores Escolha uma que produza o score m\u00e1ximo Nao \u00e9 dif\u00edcil ver que este algoritmo ing\u00eanuo pode demorar muito tempo para executar quando aumentamos o tamanho das sequencias de DNA. Uma heur\u00edstica sequencial bastante interessante para reduzir o tempo de obten\u00e7\u00e3o dos alinhamentos foi proposta por Smith e Waterman (1981), utilizando programa\u00e7\u00e3o din\u00e2mica. Abaixo, temos a descri\u00e7\u00e3o do algoritmo desta estrat\u00e9gia: ALGORITMO SMITH-WATERMAN Entrada: Duas sequencias de DNA a[i] e b[j], de tamanhos n e m respectivamente Sa\u00edda: score m\u00e1ximo de alinhamento 1. Inicializar H[i,0]=0, 0\u2264i\u2264n 2. Inicializar H[0,j]=0, 0\u2264j\u2264m 3. Para cada 1\u2264i\u2264n e 1\u2264j\u2264m: 4. Calcular diagonal = H[i-1,j-1] + w(a[i],b[j]), onde w(a[i],b[j])=2 se houve match, w(a[i],b[j])= -1 se houve mismatch e w(a[i],b[j])= -1 se houve gap 5. Calcular dele\u00e7\u00e3o = H[i-1,j] - 1 6. Calcular inser\u00e7\u00e3o = H[i,j-1] - 1 7. Calcular H[i,j]=m\u00e1ximo (0, diagonal, dele\u00e7\u00e3o, inser\u00e7\u00e3o) 9. Retornar o m\u00e1ximo de H[_,_] Os passos diagonal, dele\u00e7\u00e3o e inser\u00e7\u00e3o s\u00e3o chamados, respectivamente, de salto em diagonal, salto de cima para baixo e salto da esquerda para a direita, e representam movimenta\u00e7\u00f5es para obten\u00e7\u00e3o do alinhamento local \u00f3timo. No link abaixo, \u00e9 poss\u00edvel simular este algoritmo para diversos valores de pesos: http://rna.informatik.uni-freiburg.de/Teaching/index.jsp?toolName=Smith-Waterman Abaixo temos um exemplo da matriz H calculada para as sequ\u00eancias AGCACACA e ACACACTA: Para obter o alinhamento local \u00f3timo, come\u00e7amos com o maior valor na matriz (i,j). Ent\u00e3o, n\u00f3s vamos para tr\u00e1s para uma das posi\u00e7\u00f5es (i-1,j), (i,j-1) ou (i-1,j-1), dependendo da dire\u00e7\u00e3o de movimento usado para construir a matriz. Mantemos o processo at\u00e9 chegar a um c\u00e9lula da matriz com valor zero, ou o valor na posi\u00e7\u00e3o (0,0). No exemplo, o valor mais alto corresponde \u00e0 c\u00e9lula na posi\u00e7\u00e3o (8,8). A caminhada de volta corresponde a (8,8), (7,7), (7,6), (6,5), (5,4), (4,3), (3,2), (2,1), (1,1), e (0,0), Uma vez que tenhamos terminado, reconstruimos o alinhamento da seguinte forma: Come\u00e7ando com o \u00faltimo valor, chegamos a (i,j) usando o caminho previamente calculado. Um salto na diagonal implica que h\u00e1 um alinhamento (ou uma correspond\u00eancia ou uma n\u00e3o correspond\u00eancia). Um salto de cima para baixo implica que h\u00e1 uma dele\u00e7\u00e3o. Um salto da esquerda para a direita implica que h\u00e1 uma inser\u00e7\u00e3o. Assim, para a reconstru\u00e7\u00e3o, \u00e9 importante guardar durante a montagem da tabela H qual o tipo de salto foi utilizado. Para o exemplo das sequencias acima, obtemos o seguinte alinhamento local \u00f3timo (em rela\u00e7\u00e3o aos pesos dados para match, mismatch e gap): Sequ\u00eancia 1 = A-CACACTA Sequ\u00eancia 2 = AGCACAC-A A partir desta descri\u00e7\u00e3o, nosso primeiro projeto ter\u00e1 duas tarefas: Implementar um programa C++ para ler um arquivo contendo os tamanhos de duas sequencias de DNA, seguidos das duas sequencias, uma por linha. Calcular o score m\u00e1ximo de alinhamento local usando a heur\u00edstica de Smith-Waterman. As informa\u00e7\u00f5es para reconstru\u00e7\u00e3o dever\u00e3o ser armazenadas no formato de struct. a partir do score m\u00e1ximo, reconstruir e exibir o alinhamento local \u00f3timo das duas sequencias. No diret\u00f3rio do projeto, h\u00e1 um gerador de entradas disponibilizado como um notebook Python. Para quem estiver interessado no artigo original da heur\u00edstica de Smith-Waterman, basta consultar o link http://arep.med.harvard.edu/pdf/Smith81.pdf .","title":"Heur\u00edstica de Alinhamento Local de Smith-Waterman"}]}